# 第 4 章：DDD 中的架构模式

## 4.1 引言
   - 架构模式在 DDD 中的作用
   - 如何选择合适的架构模式

## 4.2 分层架构 (Layered Architecture)
   - **4.2.1 经典四层架构**
     - **用户界面层 (User Interface Layer / Presentation Layer)**：负责用户交互，展示数据，并将用户请求传递给应用层。
     - **应用层 (Application Layer)**：定义软件能完成的任务，协调领域对象和领域服务来完成用例。很薄的一层，不包含业务规则或知识，仅协调任务，委托工作给领域层。
     - **领域层 (Domain Layer)**：包含所有业务逻辑、领域模型（实体、值对象、聚合、领域服务、领域事件等）。是 DDD 的核心。
     - **基础设施层 (Infrastructure Layer)**：为其他层提供技术支持，如数据持久化、消息中间件、第三方库等。通过接口与领域层解耦。
   - **4.2.2 依赖倒置原则 (DIP) 在分层架构中的应用**
     - 高层模块不应该依赖于低层模块，两者都应该依赖于抽象。
     - 抽象不应该依赖于细节，细节应该依赖于抽象。
   - **4.2.3 优点与缺点**

## 4.3 六边形架构 (Hexagonal Architecture / Ports and Adapters)
   - **4.3.1核心思想**
     - 应用是核心，通过端口 (Ports) 与外部交互。
     - 外部系统（如 UI、数据库、消息队列、其他应用）通过适配器 (Adapters) 连接到端口。
     - 区分"驱动方适配器"（如 UI 控制器）和"被驱动方适配器"（如数据库 Repository 实现）。
   - **4.3.2 与分层架构的关系**
     - 可以看作是分层架构的一种演进，更强调内外分离和依赖倒置。
   - **4.3.3 优点**
     - 高内聚、低耦合，易于测试。
     - 业务逻辑与技术实现分离。
     - 易于替换和扩展外部依赖。
   - **4.3.4 实现要点**

## 4.4 CQRS (Command Query Responsibility Segregation)
   - **4.4.1 核心思想**
     - 将系统操作分为命令 (Command) 和查询 (Query) 两类。
     - 命令：改变系统状态的操作，通常是写操作，不返回值或只返回操作结果状态。
     - 查询：读取系统状态的操作，通常是读操作，不改变系统状态，返回数据。
     - 命令模型和查询模型可以独立设计和优化。
   - **4.4.2 为什么需要 CQRS？**
     - 读写分离带来的性能和扩展性优势。
     - 针对不同场景优化模型（例如，写模型关注一致性和业务规则，读模型关注查询效率和数据聚合）。
   - **4.3.3 CQRS 的不同级别**
     - 简单的逻辑分离到物理分离（不同数据库）。
   - **4.4.4 与 DDD 的结合**
     - 命令端通常与 DDD 的聚合、实体等写模型紧密相关。
     - 查询端可以构建专门的读模型 (Read Model / Projection)，甚至使用不同的数据存储。
   - **4.4.5 优点与挑战**
     - 优点：高性能、高可伸缩性、模型优化。
     - 挑战：架构复杂度增加、数据最终一致性、代码重复（如果模型差异大）。

## 4.5 事件溯源 (Event Sourcing / ES)
   - **4.5.1 核心思想**
     - 不直接存储对象的当前状态，而是存储对象状态变更所产生的一系列领域事件。
     - 当前状态可以通过聚合所有历史事件来重构。
   - **4.5.2 与传统状态存储的区别**
   - **4.5.3 优点**
     - 完整的审计日志：所有变更都有记录。
     - 调试和问题追溯方便。
     - 可以从事件流中派生出多种状态表示（投影）。
     - 时间旅行：可以查询任意时间点的历史状态。
     - 强大的分析能力。
   - **4.5.4 挑战**
     - 事件模型的演化和版本管理。
     - 查询当前状态需要重放事件，可能影响性能（通常结合快照 Snapshot 优化）。
     - 学习曲线较陡峭。
   - **4.5.5 与 DDD、CQRS 的结合**
     - ES 天然适合 DDD，因为领域事件是 DDD 的核心构建块。
     - ES 通常与 CQRS 一起使用：命令处理程序发布事件，事件被持久化并用于更新查询端的读模型。

## 4.6 本章小结 