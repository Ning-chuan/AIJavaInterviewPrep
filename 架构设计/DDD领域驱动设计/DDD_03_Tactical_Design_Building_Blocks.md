# 第 3 章：战术设计 - 构建块

## 3.1 引言
   - 什么是战术设计？
   - 战术设计与战略设计的关系
   - 战术设计的目标：构建丰富的领域模型

## 3.2 实体 (Entity)
   - **3.2.1 定义与特征**
     - 具有唯一标识符 (Identity)
     - 具有生命周期，状态可变
     - 通过标识符进行区分，而不是属性
   - **3.2.2 设计原则**
     - 保持实体的小巧和专注
     - 关注业务行为，而非仅仅是数据容器
   - **3.2.3 与数据对象的区别** (例如 ORM 中的 Entity)

## 3.3 值对象 (Value Object)
   - **3.3.1 定义与特征**
     - 用于度量或描述事物，没有唯一标识符
     - 核心特征：不变性 (Immutability)
     - 通过属性值进行比较
     - 可替换性
   - **3.3.2 设计原则与最佳实践**
     - 确保不变性
     - 作为其他实体或值对象的属性
     - 整体替换，而非修改内部状态
     - 常见例子：金额、日期范围、地址（部分属性）、颜色等
   - **3.3.3 值对象的优势**
     - 简化设计，减少副作用
     - 提升代码可读性和安全性

## 3.4 聚合 (Aggregate) 与聚合根 (Aggregate Root)
   - **3.4.1 什么是聚合？**
     - 一组相关领域对象的集合，被视为一个单元进行数据变化和一致性管理。
     - 聚合是数据持久化的基本单元。
   - **3.4.2 聚合根 (Aggregate Root)**
     - 聚合的入口点，是聚合内唯一允许被外部直接引用的实体。
     - 负责维护聚合内部的一致性规则。
     - 全局唯一标识。
   - **3.4.3 设计原则**
     - **小聚合原则**：尽可能保持聚合小，以减少锁竞争和提升性能。
     - **通过 ID 引用其他聚合**：聚合之间不直接持有对象引用，而是通过聚合根的 ID 进行关联。
     - **事务一致性边界**：一个事务只修改一个聚合实例。跨聚合的最终一致性通过领域事件等机制保证。
     - 聚合根负责其内部所有对象的不变性约束。
   - **3.4.4 如何识别聚合？**
     - 围绕业务不变性规则进行划分。
     - 考虑对象的生命周期和事务边界。

## 3.5 领域服务 (Domain Service)
   - **3.5.1 何时使用领域服务？**
     - 当某个重要的领域操作或流程不适合放在任何一个实体或值对象中时。
     - 操作涉及多个领域对象。
     - 操作是无状态的。
   - **3.5.2 特点**
     - 通常以动词或动词短语命名，体现其行为性。
     - 封装核心业务逻辑。
   - **3.5.3 与应用服务 (Application Service) 的区别**
     - 领域服务包含纯粹的领域逻辑，应用服务协调领域对象和领域服务完成用例，处理事务、安全等。

## 3.6 领域事件 (Domain Event)
   - **3.6.1 什么是领域事件？**
     - 领域中发生的具有业务意义的事情。
     - 通常用过去分词命名，如 OrderCreatedEvent。
   - **3.6.2 用途**
     - 解耦限界上下文和聚合之间的依赖。
     - 实现最终一致性。
     - 业务审计和跟踪。
     - 驱动其他业务流程。
   - **3.6.3 设计要素**
     - 事件本身是不可变的。
     - 包含事件发生的时间、源信息以及与事件相关的关键数据。
   - **3.6.4 发布与订阅机制**
     - 同步 vs 异步处理

## 3.7 工厂 (Factory)
   - **3.7.1 职责**
     - 封装创建复杂对象或聚合的逻辑。
     - 确保创建的对象满足所有不变性约束。
     - 将创建逻辑与客户代码分离。
   - **3.7.2 何时使用工厂？**
     - 对象创建过程复杂，涉及多个步骤或依赖。
     - 需要隐藏对象的具体实现类。
   - **3.7.3 工厂的类型**
     - 工厂方法 (Factory Method)
     - 抽象工厂 (Abstract Factory)
     - 聚合根自身也可以承担部分工厂职责

## 3.8 资源库 (Repository)
   - **3.8.1 职责**
     - 封装领域对象的持久化和检索逻辑，为领域层提供数据访问的抽象接口。
     - 模拟一个内存中的对象集合，使领域层感觉不到持久化机制的存在。
   - **3.8.2 设计原则**
     - 接口定义在领域层，实现在基础设施层。
     - 通常针对聚合根进行设计，一个聚合根对应一个资源库。
     - 方法命名体现业务意图 (例如 `findByCustomerId`, `save`)。
   - **3.8.3 与数据访问对象 (DAO) 的区别**
     - Repository 关注领域对象的生命周期管理，DAO 更关注数据表的 CRUD 操作。
     - Repository 返回领域对象（聚合），DAO 返回数据传输对象 (DTO) 或简单数据结构。

## 3.9 本章小结 