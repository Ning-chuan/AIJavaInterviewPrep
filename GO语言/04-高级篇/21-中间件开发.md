# 第21章：中间件开发

## 章节概要
本章深入讲解GO语言中间件的设计和开发，包括HTTP中间件、gRPC中间件、消息中间件以及各种系统中间件的实现原理和最佳实践。中间件是现代服务架构中不可或缺的组件，掌握中间件开发技术对于构建高性能、可扩展的系统至关重要。

## 学习目标
- 理解中间件的设计模式和原理
- 掌握各种中间件的开发技术
- 学会设计可复用的中间件组件
- 了解中间件的性能优化技巧

## 主要内容

### 21.1 中间件基础概念

#### 中间件的定义和作用
中间件（Middleware）是位于应用程序、操作系统和数据库之间的软件层，用于处理通用的、横切关注点（Cross-cutting concerns）的功能。在Go语言中，中间件通常表现为一个函数，它接收一个处理函数作为输入，并返回一个新的处理函数作为输出。

**中间件的主要作用：**
- 横切关注点处理：日志记录、错误处理、认证授权等
- 请求/响应转换：格式转换、数据验证、内容协商等
- 性能优化：缓存、压缩、连接池管理等
- 安全防护：防止XSS、CSRF、SQL注入等攻击

#### 中间件设计模式
Go语言中间件常用的设计模式包括：

**1. 装饰器模式（Decorator Pattern）**：通过包装原有处理函数，添加额外功能。

```go
// 基本的HTTP处理函数类型
type HandlerFunc func(w http.ResponseWriter, r *http.Request)

// 日志中间件
func LoggerMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        startTime := time.Now()
        
        // 调用下一个处理函数
        next(w, r)
        
        // 记录请求处理时间
        log.Printf("请求处理完成 [%s] %s 耗时: %v", 
            r.Method, r.URL.Path, time.Since(startTime))
    }
}
```

**2. 管道模式（Pipeline Pattern）**：将多个中间件连接成处理链。

```go
// 中间件链
type MiddlewareChain []func(HandlerFunc) HandlerFunc

// 应用中间件链
func (mc MiddlewareChain) Apply(h HandlerFunc) HandlerFunc {
    for i := len(mc) - 1; i >= 0; i-- {
        h = mc[i](h)
    }
    return h
}
```

#### 责任链模式应用
责任链模式（Chain of Responsibility）是中间件实现的核心模式，它允许多个处理对象依次处理请求。

```go
// 实现一个简单的责任链中间件系统
type MiddlewareFunc func(http.Handler) http.Handler

// 责任链构建器
type Chain struct {
    middlewares []MiddlewareFunc
}

// 创建新的责任链
func NewChain(middlewares ...MiddlewareFunc) Chain {
    return Chain{middlewares: append([]MiddlewareFunc{}, middlewares...)}
}

// 将责任链应用到处理器
func (c Chain) Then(h http.Handler) http.Handler {
    if h == nil {
        h = http.DefaultServeMux
    }
    
    for i := len(c.middlewares) - 1; i >= 0; i-- {
        h = c.middlewares[i](h)
    }
    
    return h
}
```

#### 中间件的分类和特点

**按应用领域分类：**
1. **HTTP中间件**：处理HTTP请求和响应
2. **RPC中间件**：处理远程过程调用
3. **数据中间件**：处理数据访问和处理
4. **消息中间件**：处理消息传递和队列
5. **安全中间件**：处理认证、授权和加密

**按处理方式分类：**
1. **前置处理中间件**：在主逻辑前执行
2. **后置处理中间件**：在主逻辑后执行
3. **环绕处理中间件**：在主逻辑前后都执行
4. **错误处理中间件**：捕获并处理错误

### 21.2 HTTP中间件开发

#### HTTP中间件架构
Go标准库的`net/http`包提供了基础的HTTP服务功能，而HTTP中间件则构建在`http.Handler`接口之上。

```go
// http.Handler接口
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}

// 中间件函数签名
type Middleware func(http.Handler) http.Handler
```

HTTP中间件的基本架构包括：
1. **输入层**：接收HTTP请求
2. **中间件链**：一系列按顺序执行的中间件
3. **处理层**：实际业务逻辑
4. **输出层**：返回HTTP响应

#### 请求/响应拦截器
请求拦截器用于在请求到达处理函数前对请求进行预处理，响应拦截器用于在响应返回前对响应进行后处理。

```go
// 请求拦截中间件
func RequestInterceptor(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 请求前处理
        r = r.WithContext(context.WithValue(r.Context(), "requestStartTime", time.Now()))
        
        // 调用下一个处理器
        next.ServeHTTP(w, r)
    })
}

// 响应拦截中间件
func ResponseInterceptor(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 创建自定义ResponseWriter
        rw := &responseWriter{ResponseWriter: w, statusCode: http.StatusOK}
        
        // 调用下一个处理器
        next.ServeHTTP(rw, r)
        
        // 响应后处理
        log.Printf("响应状态码: %d", rw.statusCode)
    })
}

// 自定义ResponseWriter
type responseWriter struct {
    http.ResponseWriter
    statusCode int
}

func (rw *responseWriter) WriteHeader(code int) {
    rw.statusCode = code
    rw.ResponseWriter.WriteHeader(code)
}
```

#### 认证和授权中间件
认证中间件验证用户身份，授权中间件检查用户权限。

```go
// JWT认证中间件
func JWTAuthMiddleware(secret string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 从请求头中获取token
            tokenString := r.Header.Get("Authorization")
            if tokenString == "" {
                http.Error(w, "未授权访问", http.StatusUnauthorized)
                return
            }
            
            // 验证token（简化示例）
            tokenString = strings.Replace(tokenString, "Bearer ", "", 1)
            
            // 这里应该有实际的JWT验证逻辑
            // claims, err := verifyToken(tokenString, secret)
            
            // 将用户信息放入上下文
            ctx := context.WithValue(r.Context(), "userID", "user123")
            
            // 调用下一个处理器
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}

// 角色授权中间件
func RoleAuthMiddleware(requiredRole string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 从上下文中获取用户ID
            userID, ok := r.Context().Value("userID").(string)
            if !ok {
                http.Error(w, "未授权访问", http.StatusUnauthorized)
                return
            }
            
            // 获取用户角色（示例）
            userRole := getUserRole(userID) // 实际应从数据库或缓存获取
            
            // 检查角色
            if userRole != requiredRole {
                http.Error(w, "权限不足", http.StatusForbidden)
                return
            }
            
            // 调用下一个处理器
            next.ServeHTTP(w, r)
        })
    }
}

// 模拟获取用户角色
func getUserRole(userID string) string {
    // 实际应从数据库或缓存获取
    return "admin"
}
```

#### 日志和监控中间件
日志中间件记录请求信息，监控中间件收集性能指标。

```go
// 请求日志中间件
func RequestLoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 包装ResponseWriter以捕获状态码
        wrappedWriter := &statusCapturingResponseWriter{
            ResponseWriter: w,
            status:         http.StatusOK,
        }
        
        // 处理请求
        next.ServeHTTP(wrappedWriter, r)
        
        // 记录请求日志
        duration := time.Since(start)
        log.Printf(
            "[%s] %s %s %d %v",
            r.Method,
            r.RequestURI,
            r.RemoteAddr,
            wrappedWriter.status,
            duration,
        )
    })
}

// 包装ResponseWriter以捕获状态码
type statusCapturingResponseWriter struct {
    http.ResponseWriter
    status int
}

func (w *statusCapturingResponseWriter) WriteHeader(status int) {
    w.status = status
    w.ResponseWriter.WriteHeader(status)
}

// 指标收集中间件
func MetricsMiddleware(next http.Handler) http.Handler {
    // 在实际应用中，你可能会使用像Prometheus这样的监控系统
    requestCounter := 0
    requestDurations := make([]time.Duration, 0)
    
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 调用下一个处理器
        next.ServeHTTP(w, r)
        
        // 收集指标
        duration := time.Since(start)
        requestCounter++
        requestDurations = append(requestDurations, duration)
        
        // 在实际应用中，你会将这些指标发送到监控系统
        // 这里只是简单记录
        log.Printf("总请求数: %d, 当前请求耗时: %v", requestCounter, duration)
    })
}
```

### 21.3 Web框架中间件

#### Gin中间件开发
Gin是Go最流行的Web框架之一，它提供了简单而强大的中间件系统。

```go
// Gin中间件基本结构
func GinMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        // 前置处理
        startTime := time.Now()
        
        // 调用下一个处理器
        c.Next()
        
        // 后置处理
        duration := time.Since(startTime)
        log.Printf("API %s 耗时: %v", c.FullPath(), duration)
    }
}

// Gin全局异常处理中间件
func GinRecoveryMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // 记录堆栈信息
                stack := make([]byte, 4096)
                stack = stack[:runtime.Stack(stack, false)]
                log.Printf("发生错误: %v\n%s", err, stack)
                
                // 返回500错误
                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                    "error": "服务器内部错误",
                })
            }
        }()
        
        c.Next()
    }
}

// 使用Gin中间件示例
func setupGinRouter() *gin.Engine {
    r := gin.New()
    
    // 全局中间件
    r.Use(GinMiddleware())
    r.Use(GinRecoveryMiddleware())
    
    // 路由组中间件
    authorized := r.Group("/")
    authorized.Use(AuthRequired())
    {
        authorized.GET("/user/:id", getUserHandler)
        authorized.POST("/user", createUserHandler)
    }
    
    return r
}

// 身份验证中间件
func AuthRequired() gin.HandlerFunc {
    return func(c *gin.Context) {
        token := c.GetHeader("Authorization")
        if token == "" {
            c.AbortWithStatusJSON(http.StatusUnauthorized, gin.H{"error": "未授权访问"})
            return
        }
        
        // 验证token并设置用户信息
        c.Set("userID", "user123")
        c.Next()
    }
}
```

#### Echo中间件实现
Echo是另一个轻量级高性能的Go Web框架，它也有强大的中间件支持。

```go
// Echo中间件基本结构
func EchoMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        // 前置处理
        startTime := time.Now()
        
        // 调用下一个处理器
        err := next(c)
        
        // 后置处理
        duration := time.Since(startTime)
        log.Printf("Echo API %s 耗时: %v", c.Path(), duration)
        
        return err
    }
}

// Echo请求ID中间件
func RequestIDMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        // 生成请求ID
        requestID := uuid.New().String()
        
        // 设置请求ID到响应头
        c.Response().Header().Set("X-Request-ID", requestID)
        
        // 设置请求ID到上下文
        c.Set("requestID", requestID)
        
        return next(c)
    }
}

// 使用Echo中间件示例
func setupEchoRouter() *echo.Echo {
    e := echo.New()
    
    // 全局中间件
    e.Use(middleware.Logger())
    e.Use(middleware.Recover())
    e.Use(EchoMiddleware)
    e.Use(RequestIDMiddleware)
    
    // 路由中间件
    g := e.Group("/api")
    g.Use(AuthMiddleware)
    
    g.GET("/users/:id", getUserHandler)
    g.POST("/users", createUserHandler)
    
    return e
}

// Echo认证中间件
func AuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc {
    return func(c echo.Context) error {
        token := c.Request().Header.Get("Authorization")
        if token == "" {
            return echo.NewHTTPError(http.StatusUnauthorized, "未授权访问")
        }
        
        // 验证token并设置用户信息
        c.Set("userID", "user123")
        
        return next(c)
    }
}
```

#### 自定义中间件框架
有时我们需要开发自己的中间件框架，以满足特定需求。

```go
// 定义处理函数类型
type Handler func(ctx *Context)

// 自定义上下文
type Context struct {
    Request  *http.Request
    Response http.ResponseWriter
    Params   map[string]string
    Data     map[string]interface{}
}

// 中间件类型
type Middleware func(Handler) Handler

// 中间件链
type MiddlewareChain struct {
    middlewares []Middleware
}

// 创建新的中间件链
func NewMiddlewareChain() *MiddlewareChain {
    return &MiddlewareChain{
        middlewares: make([]Middleware, 0),
    }
}

// 添加中间件
func (c *MiddlewareChain) Use(m Middleware) {
    c.middlewares = append(c.middlewares, m)
}

// 应用中间件链
func (c *MiddlewareChain) Apply(h Handler) Handler {
    for i := len(c.middlewares) - 1; i >= 0; i-- {
        h = c.middlewares[i](h)
    }
    return h
}

// 使用示例
func ExampleCustomMiddleware() {
    // 创建中间件链
    chain := NewMiddlewareChain()
    
    // 添加日志中间件
    chain.Use(func(next Handler) Handler {
        return func(ctx *Context) {
            start := time.Now()
            next(ctx)
            log.Printf("请求处理耗时: %v", time.Since(start))
        }
    })
    
    // 添加认证中间件
    chain.Use(func(next Handler) Handler {
        return func(ctx *Context) {
            token := ctx.Request.Header.Get("Authorization")
            if token == "" {
                ctx.Response.WriteHeader(http.StatusUnauthorized)
                ctx.Response.Write([]byte("未授权访问"))
                return
            }
            next(ctx)
        }
    })
    
    // 最终处理函数
    finalHandler := func(ctx *Context) {
        ctx.Response.Write([]byte("Hello, World!"))
    }
    
    // 应用中间件链
    handler := chain.Apply(finalHandler)
    
    // 创建上下文并处理请求
    ctx := &Context{
        Request:  &http.Request{},
        Response: &responseWriterMock{},
        Params:   make(map[string]string),
        Data:     make(map[string]interface{}),
    }
    
    handler(ctx)
}

// 响应写入器模拟
type responseWriterMock struct {
    headers    http.Header
    statusCode int
    body       []byte
}

func (w *responseWriterMock) Header() http.Header {
    if w.headers == nil {
        w.headers = make(http.Header)
    }
    return w.headers
}

func (w *responseWriterMock) Write(b []byte) (int, error) {
    w.body = append(w.body, b...)
    return len(b), nil
}

func (w *responseWriterMock) WriteHeader(statusCode int) {
    w.statusCode = statusCode
}
```

#### 中间件性能优化
中间件性能优化是确保应用高效运行的关键。

**优化策略：**

1. **避免不必要的内存分配**
```go
// 不好的做法 - 每个请求都创建新的切片
func BadMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        buffer := make([]byte, 1024) // 每个请求都分配
        // ...使用buffer
        next.ServeHTTP(w, r)
    })
}

// 好的做法 - 使用sync.Pool重用对象
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

func GoodMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        buffer := bufferPool.Get().([]byte)
        defer bufferPool.Put(buffer)
        // ...使用buffer
        next.ServeHTTP(w, r)
    })
}
```

2. **减少中间件数量**
```go
// 合并功能相似的中间件
func CombinedMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 日志功能
        start := time.Now()
        
        // 请求ID功能
        requestID := uuid.New().String()
        w.Header().Set("X-Request-ID", requestID)
        
        // 调用下一个处理器
        next.ServeHTTP(w, r)
        
        // 记录耗时
        log.Printf("[%s] 请求处理耗时: %v", requestID, time.Since(start))
    })
}
```

3. **有条件执行中间件**
```go
// 条件中间件
func ConditionalMiddleware(condition func(*http.Request) bool, middleware func(http.Handler) http.Handler) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            if condition(r) {
                middleware(next).ServeHTTP(w, r)
            } else {
                next.ServeHTTP(w, r)
            }
        })
    }
}

// 使用示例
router.Use(ConditionalMiddleware(
    func(r *http.Request) bool {
        return strings.HasPrefix(r.URL.Path, "/api")
    },
    AuthMiddleware,
))
```

4. **减少上下文切换**
```go
// 避免在中间件中进行阻塞操作
func NonBlockingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 不要在这里进行阻塞操作，如数据库查询
        // 错误示例: dbConn.Query("SELECT * FROM users")
        
        // 正确做法：将长时间操作放入goroutine
        go func() {
            // 执行耗时操作，如异步日志记录
            // 注意：此时不应再使用w和r，因为请求可能已经完成
        }()
        
        next.ServeHTTP(w, r)
    })
}
```

### 21.4 gRPC中间件

#### gRPC拦截器原理
gRPC是一个高性能的RPC框架，支持通过拦截器（Interceptor）实现中间件功能。gRPC拦截器分为两种类型：一元拦截器（Unary Interceptor）和流式拦截器（Stream Interceptor）。

**gRPC拦截器的工作原理：**

1. **服务端拦截器**：在服务端接收到请求后，调用处理函数之前执行
2. **客户端拦截器**：在客户端发送请求之前执行

gRPC拦截器的执行流程：
```
客户端请求 → 客户端拦截器 → gRPC网络传输 → 服务端拦截器 → 服务方法 → 服务端拦截器 → gRPC网络传输 → 客户端拦截器 → 客户端接收响应
```

#### 一元拦截器开发
一元拦截器用于处理简单的RPC调用，即请求和响应都是单个消息的场景。

**服务端一元拦截器：**
```go
// 服务端一元拦截器
func UnaryServerInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    // 前置处理
    log.Printf("开始处理一元RPC: %s", info.FullMethod)
    startTime := time.Now()
    
    // 调用处理函数
    resp, err := handler(ctx, req)
    
    // 后置处理
    log.Printf("一元RPC处理完成: %s, 耗时: %v", info.FullMethod, time.Since(startTime))
    
    return resp, err
}

// 使用一元拦截器创建gRPC服务
func NewGrpcServer() *grpc.Server {
    server := grpc.NewServer(
        grpc.UnaryInterceptor(UnaryServerInterceptor),
    )
    return server
}
```

**客户端一元拦截器：**
```go
// 客户端一元拦截器
func UnaryClientInterceptor(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
    // 前置处理
    log.Printf("开始发送一元RPC请求: %s", method)
    startTime := time.Now()
    
    // 调用RPC方法
    err := invoker(ctx, method, req, reply, cc, opts...)
    
    // 后置处理
    log.Printf("一元RPC请求完成: %s, 耗时: %v", method, time.Since(startTime))
    
    return err
}

// 使用一元拦截器创建gRPC客户端连接
func NewGrpcClientConn(target string) (*grpc.ClientConn, error) {
    return grpc.Dial(
        target,
        grpc.WithInsecure(),
        grpc.WithUnaryInterceptor(UnaryClientInterceptor),
    )
}
```

#### 流式拦截器实现
流式拦截器用于处理流式RPC调用，即请求或响应（或两者）是消息流的场景。

**服务端流式拦截器：**
```go
// 服务端流式拦截器
func StreamServerInterceptor(srv interface{}, ss grpc.ServerStream, info *grpc.StreamServerInfo, handler grpc.StreamHandler) error {
    // 前置处理
    log.Printf("开始处理流式RPC: %s", info.FullMethod)
    startTime := time.Now()
    
    // 包装ServerStream以便拦截消息
    wrappedStream := &wrappedServerStream{
        ServerStream: ss,
        fullMethod:   info.FullMethod,
    }
    
    // 调用处理函数
    err := handler(srv, wrappedStream)
    
    // 后置处理
    log.Printf("流式RPC处理完成: %s, 耗时: %v", info.FullMethod, time.Since(startTime))
    
    return err
}

// 包装ServerStream
type wrappedServerStream struct {
    grpc.ServerStream
    fullMethod string
}

func (w *wrappedServerStream) RecvMsg(m interface{}) error {
    err := w.ServerStream.RecvMsg(m)
    if err == nil {
        log.Printf("接收到流消息: %s", w.fullMethod)
    }
    return err
}

func (w *wrappedServerStream) SendMsg(m interface{}) error {
    log.Printf("发送流消息: %s", w.fullMethod)
    return w.ServerStream.SendMsg(m)
}

// 使用流式拦截器创建gRPC服务
func NewGrpcServerWithStreamInterceptor() *grpc.Server {
    server := grpc.NewServer(
        grpc.StreamInterceptor(StreamServerInterceptor),
    )
    return server
}
```

**客户端流式拦截器：**
```go
// 客户端流式拦截器
func StreamClientInterceptor(ctx context.Context, desc *grpc.StreamDesc, cc *grpc.ClientConn, method string, streamer grpc.Streamer, opts ...grpc.CallOption) (grpc.ClientStream, error) {
    // 前置处理
    log.Printf("开始发送流式RPC请求: %s", method)
    startTime := time.Now()
    
    // 调用流式RPC方法
    clientStream, err := streamer(ctx, desc, cc, method, opts...)
    if err != nil {
        return nil, err
    }
    
    // 包装ClientStream
    wrappedStream := &wrappedClientStream{
        ClientStream: clientStream,
        method:       method,
        startTime:    startTime,
    }
    
    return wrappedStream, nil
}

// 包装ClientStream
type wrappedClientStream struct {
    grpc.ClientStream
    method    string
    startTime time.Time
}

func (w *wrappedClientStream) RecvMsg(m interface{}) error {
    err := w.ClientStream.RecvMsg(m)
    if err == nil {
        log.Printf("接收到流消息: %s", w.method)
    } else if err == io.EOF {
        log.Printf("流式RPC请求完成: %s, 耗时: %v", w.method, time.Since(w.startTime))
    }
    return err
}

func (w *wrappedClientStream) SendMsg(m interface{}) error {
    log.Printf("发送流消息: %s", w.method)
    return w.ClientStream.SendMsg(m)
}

// 使用流式拦截器创建gRPC客户端连接
func NewGrpcClientConnWithStreamInterceptor(target string) (*grpc.ClientConn, error) {
    return grpc.Dial(
        target,
        grpc.WithInsecure(),
        grpc.WithStreamInterceptor(StreamClientInterceptor),
    )
}
```

#### gRPC中间件链
在实际应用中，我们通常需要使用多个拦截器。gRPC默认只支持设置一个拦截器，但我们可以使用第三方库或自己实现中间件链。

**使用go-grpc-middleware库：**
```go
import (
    "github.com/grpc-ecosystem/go-grpc-middleware"
)

// 创建带有多个一元拦截器的服务器
func NewServerWithMultipleInterceptors() *grpc.Server {
    return grpc.NewServer(
        grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
            LoggingInterceptor,
            AuthInterceptor,
            MetricsInterceptor,
        )),
        grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
            StreamLoggingInterceptor,
            StreamAuthInterceptor,
            StreamMetricsInterceptor,
        )),
    )
}

// 创建带有多个一元拦截器的客户端
func NewClientWithMultipleInterceptors(target string) (*grpc.ClientConn, error) {
    return grpc.Dial(
        target,
        grpc.WithInsecure(),
        grpc.WithUnaryInterceptor(grpc_middleware.ChainUnaryClient(
            ClientLoggingInterceptor,
            ClientRetryInterceptor,
            ClientTimeoutInterceptor,
        )),
        grpc.WithStreamInterceptor(grpc_middleware.ChainStreamClient(
            ClientStreamLoggingInterceptor,
            ClientStreamRetryInterceptor,
        )),
    )
}
```

**自定义拦截器链实现：**
```go
// 链式一元服务端拦截器
func ChainUnaryServerInterceptors(interceptors ...grpc.UnaryServerInterceptor) grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        buildChain := func(current grpc.UnaryServerInterceptor, next grpc.UnaryHandler) grpc.UnaryHandler {
            return func(currentCtx context.Context, currentReq interface{}) (interface{}, error) {
                return current(currentCtx, currentReq, info, next)
            }
        }
        
        chain := handler
        for i := len(interceptors) - 1; i >= 0; i-- {
            chain = buildChain(interceptors[i], chain)
        }
        
        return chain(ctx, req)
    }
}

// 使用自定义链式拦截器
func NewServerWithCustomChain() *grpc.Server {
    return grpc.NewServer(
        grpc.UnaryInterceptor(ChainUnaryServerInterceptors(
            LoggingInterceptor,
            AuthInterceptor,
            MetricsInterceptor,
        )),
    )
}
```

**实用的gRPC拦截器示例：**

```go
// 超时控制拦截器
func TimeoutInterceptor(timeout time.Duration) grpc.UnaryServerInterceptor {
    return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
        // 创建带有超时的上下文
        timeoutCtx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()
        
        // 使用带超时的上下文调用处理函数
        return handler(timeoutCtx, req)
    }
}

// 重试拦截器
func RetryInterceptor(maxRetries int) grpc.UnaryClientInterceptor {
    return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
        var lastErr error
        
        for i := 0; i < maxRetries; i++ {
            if err := invoker(ctx, method, req, reply, cc, opts...); err != nil {
                lastErr = err
                // 判断是否可重试的错误
                if code := status.Code(err); code == codes.Unavailable || code == codes.DeadlineExceeded {
                    log.Printf("重试RPC请求: %s, 尝试次数: %d", method, i+1)
                    continue
                }
                return err
            }
            return nil
        }
        
        return lastErr
    }
}

// 元数据传递拦截器
func MetadataInterceptor(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) {
    md, ok := metadata.FromIncomingContext(ctx)
    if !ok {
        md = metadata.New(nil)
    }
    
    // 添加服务器信息到元数据
    newMD := metadata.New(map[string]string{
        "server": "go-grpc-server",
        "version": "1.0.0",
    })
    md = metadata.Join(md, newMD)
    
    // 创建新的上下文，带有更新后的元数据
    newCtx := metadata.NewIncomingContext(ctx, md)
    
    return handler(newCtx, req)
}
```

### 21.5 数据库中间件
- 数据库连接池中间件
- 读写分离中间件
- 分库分表中间件
- 数据库监控中间件

### 21.6 缓存中间件

#### 缓存抽象层设计
缓存抽象层提供统一的接口，使应用程序可以透明地使用不同的缓存实现（如内存缓存、Redis缓存等）。

```go
// 缓存接口
type Cache interface {
    // 设置缓存，带过期时间
    Set(key string, value interface{}, expiration time.Duration) error
    // 获取缓存
    Get(key string) (interface{}, bool, error)
    // 删除缓存
    Delete(key string) error
    // 检查缓存是否存在
    Exists(key string) (bool, error)
    // 设置缓存（如果不存在）
    SetNX(key string, value interface{}, expiration time.Duration) (bool, error)
    // 清空所有缓存
    Clear() error
}

// 内存缓存实现
type MemoryCache struct {
    data  map[string]cacheItem
    mu    sync.RWMutex
}

// 缓存项
type cacheItem struct {
    value      interface{}
    expiration time.Time
}

// 创建内存缓存
func NewMemoryCache() *MemoryCache {
    cache := &MemoryCache{
        data: make(map[string]cacheItem),
    }
    
    // 启动清理过期项的协程
    go cache.cleanExpired()
    
    return cache
}

// 设置缓存
func (c *MemoryCache) Set(key string, value interface{}, expiration time.Duration) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    var exp time.Time
    if expiration > 0 {
        exp = time.Now().Add(expiration)
    }
    
    c.data[key] = cacheItem{
        value:      value,
        expiration: exp,
    }
    
    return nil
}

// 获取缓存
func (c *MemoryCache) Get(key string) (interface{}, bool, error) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    item, found := c.data[key]
    if !found {
        return nil, false, nil
    }
    
    // 检查是否过期
    if !item.expiration.IsZero() && item.expiration.Before(time.Now()) {
        return nil, false, nil
    }
    
    return item.value, true, nil
}

// 删除缓存
func (c *MemoryCache) Delete(key string) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    delete(c.data, key)
    return nil
}

// 检查缓存是否存在
func (c *MemoryCache) Exists(key string) (bool, error) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    item, found := c.data[key]
    if !found {
        return false, nil
    }
    
    // 检查是否过期
    if !item.expiration.IsZero() && item.expiration.Before(time.Now()) {
        return false, nil
    }
    
    return true, nil
}

// 设置缓存（如果不存在）
func (c *MemoryCache) SetNX(key string, value interface{}, expiration time.Duration) (bool, error) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    item, found := c.data[key]
    if found && (item.expiration.IsZero() || item.expiration.After(time.Now())) {
        return false, nil
    }
    
    var exp time.Time
    if expiration > 0 {
        exp = time.Now().Add(expiration)
    }
    
    c.data[key] = cacheItem{
        value:      value,
        expiration: exp,
    }
    
    return true, nil
}

// 清空所有缓存
func (c *MemoryCache) Clear() error {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.data = make(map[string]cacheItem)
    return nil
}

// 清理过期项
func (c *MemoryCache) cleanExpired() {
    ticker := time.NewTicker(5 * time.Minute)
    defer ticker.Stop()
    
    for range ticker.C {
        c.mu.Lock()
        now := time.Now()
        for key, item := range c.data {
            if !item.expiration.IsZero() && item.expiration.Before(now) {
                delete(c.data, key)
            }
        }
        c.mu.Unlock()
    }
}

// Redis缓存实现（示例，实际需要引入Redis客户端库）
type RedisCache struct {
    client interface{} // 实际应使用redis.Client或类似实现
    prefix string
}

// 使用示例
func ExampleCacheAbstraction() {
    // 创建内存缓存
    cache := NewMemoryCache()
    
    // 设置缓存
    err := cache.Set("user:123", User{ID: 123, Name: "张三"}, 5*time.Minute)
    if err != nil {
        log.Fatalf("设置缓存失败: %v", err)
    }
    
    // 获取缓存
    value, found, err := cache.Get("user:123")
    if err != nil {
        log.Fatalf("获取缓存失败: %v", err)
    }
    
    if found {
        user, ok := value.(User)
        if ok {
            log.Printf("从缓存获取用户: ID=%d, Name=%s", user.ID, user.Name)
        }
    } else {
        log.Println("缓存未命中")
    }
}

// 用户结构体（示例）
type User struct {
    ID   int
    Name string
}
```

#### 多级缓存中间件
多级缓存中间件允许应用程序使用多个缓存层，如本地内存缓存和分布式缓存，提高性能并减轻后端服务负载。

```go
// 多级缓存中间件
type MultiLevelCache struct {
    caches []CacheLevel
}

// 缓存级别
type CacheLevel struct {
    cache Cache
    name  string
    ttl   time.Duration
}

// 创建多级缓存
func NewMultiLevelCache(levels []CacheLevel) *MultiLevelCache {
    return &MultiLevelCache{
        caches: levels,
    }
}

// 设置缓存（在所有级别）
func (c *MultiLevelCache) Set(key string, value interface{}) error {
    var lastErr error
    
    // 设置所有缓存级别
    for _, level := range c.caches {
        if err := level.cache.Set(key, value, level.ttl); err != nil {
            lastErr = fmt.Errorf("设置%s缓存失败: %w", level.name, err)
            log.Printf("警告: %v", lastErr)
        }
    }
    
    return lastErr
}

// 获取缓存（从最快的级别开始查找）
func (c *MultiLevelCache) Get(key string) (interface{}, bool, error) {
    // 从最快的缓存级别开始查找
    for i, level := range c.caches {
        value, found, err := level.cache.Get(key)
        if err != nil {
            log.Printf("从%s获取缓存失败: %v", level.name, err)
            continue
        }
        
        if found {
            // 找到数据，填充较低级别的缓存
            c.fillLowerLevels(key, value, i)
            return value, true, nil
        }
    }
    
    return nil, false, nil
}

// 填充较低级别的缓存
func (c *MultiLevelCache) fillLowerLevels(key string, value interface{}, foundIndex int) {
    for i := 0; i < foundIndex; i++ {
        level := c.caches[i]
        if err := level.cache.Set(key, value, level.ttl); err != nil {
            log.Printf("填充%s缓存失败: %v", level.name, err)
        }
    }
}

// 删除缓存（从所有级别）
func (c *MultiLevelCache) Delete(key string) error {
    var lastErr error
    
    // 从所有缓存级别删除
    for _, level := range c.caches {
        if err := level.cache.Delete(key); err != nil {
            lastErr = fmt.Errorf("从%s删除缓存失败: %w", level.name, err)
            log.Printf("警告: %v", lastErr)
        }
    }
    
    return lastErr
}

// 使用示例
func ExampleMultiLevelCache() {
    // 创建两级缓存
    memCache := NewMemoryCache()
    redisCache := &RedisCache{} // 实际应初始化Redis客户端
    
    multiCache := NewMultiLevelCache([]CacheLevel{
        {cache: memCache, name: "内存缓存", ttl: 1 * time.Minute},
        {cache: redisCache, name: "Redis缓存", ttl: 10 * time.Minute},
    })
    
    // 设置缓存
    err := multiCache.Set("user:123", User{ID: 123, Name: "张三"})
    if err != nil {
        log.Printf("设置多级缓存警告: %v", err)
    }
    
    // 获取缓存
    value, found, err := multiCache.Get("user:123")
    if err != nil {
        log.Fatalf("获取多级缓存失败: %v", err)
    }
    
    if found {
        user, ok := value.(User)
        if ok {
            log.Printf("从多级缓存获取用户: ID=%d, Name=%s", user.ID, user.Name)
        }
    }
}
```

#### 缓存一致性中间件
缓存一致性中间件用于保证缓存数据与数据源（如数据库）的数据一致性，避免缓存数据过期或不一致的问题。

```go
// 缓存更新策略
type CacheUpdateStrategy int

const (
    // 写直达：先更新数据源，再更新缓存
    WriteThrough CacheUpdateStrategy = iota
    // 写回：先更新缓存，异步更新数据源
    WriteBack
    // 写无效：更新数据源，使缓存失效
    WriteInvalidate
)

// 缓存一致性中间件
type CacheConsistencyMiddleware struct {
    cache           Cache
    db              *sql.DB
    updateStrategy  CacheUpdateStrategy
    writeBackQueue  chan writeBackTask
}

// 写回任务
type writeBackTask struct {
    query string
    args  []interface{}
}

// 创建缓存一致性中间件
func NewCacheConsistencyMiddleware(cache Cache, db *sql.DB, strategy CacheUpdateStrategy) *CacheConsistencyMiddleware {
    middleware := &CacheConsistencyMiddleware{
        cache:          cache,
        db:             db,
        updateStrategy: strategy,
    }
    
    // 如果是写回策略，启动写回处理协程
    if strategy == WriteBack {
        middleware.writeBackQueue = make(chan writeBackTask, 1000)
        go middleware.processWriteBack()
    }
    
    return middleware
}

// 处理写回任务
func (m *CacheConsistencyMiddleware) processWriteBack() {
    for task := range m.writeBackQueue {
        // 重试机制
        for i := 0; i < 3; i++ {
            _, err := m.db.Exec(task.query, task.args...)
            if err == nil {
                break
            }
            
            log.Printf("写回数据库失败 (尝试 %d/3): %v", i+1, err)
            time.Sleep(time.Second * time.Duration(i+1))
        }
    }
}

// 根据ID获取用户
func (m *CacheConsistencyMiddleware) GetUserByID(id int) (*User, error) {
    // 先尝试从缓存获取
    cacheKey := fmt.Sprintf("user:%d", id)
    value, found, err := m.cache.Get(cacheKey)
    if err != nil {
        return nil, fmt.Errorf("从缓存获取失败: %w", err)
    }
    
    if found {
        user, ok := value.(*User)
        if ok {
            return user, nil
        }
    }
    
    // 缓存未命中，从数据库获取
    user := &User{}
    err = m.db.QueryRow("SELECT id, name FROM users WHERE id = ?", id).Scan(&user.ID, &user.Name)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil
        }
        return nil, fmt.Errorf("从数据库获取失败: %w", err)
    }
    
    // 更新缓存
    if err := m.cache.Set(cacheKey, user, 5*time.Minute); err != nil {
        log.Printf("更新缓存失败: %v", err)
    }
    
    return user, nil
}

// 更新用户
func (m *CacheConsistencyMiddleware) UpdateUser(user *User) error {
    cacheKey := fmt.Sprintf("user:%d", user.ID)
    
    switch m.updateStrategy {
    case WriteThrough:
        // 写直达：先更新数据库，再更新缓存
        if err := m.updateUserDB(user); err != nil {
            return err
        }
        
        return m.cache.Set(cacheKey, user, 5*time.Minute)
        
    case WriteBack:
        // 写回：先更新缓存，异步更新数据库
        if err := m.cache.Set(cacheKey, user, 5*time.Minute); err != nil {
            return err
        }
        
        m.writeBackQueue <- writeBackTask{
            query: "UPDATE users SET name = ? WHERE id = ?",
            args:  []interface{}{user.Name, user.ID},
        }
        
        return nil
        
    case WriteInvalidate:
        // 写无效：更新数据库，使缓存失效
        if err := m.updateUserDB(user); err != nil {
            return err
        }
        
        return m.cache.Delete(cacheKey)
        
    default:
        return fmt.Errorf("未知的缓存更新策略: %v", m.updateStrategy)
    }
}

// 更新用户到数据库
func (m *CacheConsistencyMiddleware) updateUserDB(user *User) error {
    _, err := m.db.Exec("UPDATE users SET name = ? WHERE id = ?", user.Name, user.ID)
    if err != nil {
        return fmt.Errorf("更新数据库失败: %w", err)
    }
    return nil
}

// 使用示例
func ExampleCacheConsistencyMiddleware() {
    // 创建缓存和数据库连接
    cache := NewMemoryCache()
    db, _ := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/dbname")
    
    // 创建缓存一致性中间件
    middleware := NewCacheConsistencyMiddleware(cache, db, WriteThrough)
    
    // 获取用户
    user, err := middleware.GetUserByID(123)
    if err != nil {
        log.Fatalf("获取用户失败: %v", err)
    }
    
    if user != nil {
        log.Printf("用户: ID=%d, Name=%s", user.ID, user.Name)
        
        // 更新用户
        user.Name = "李四"
        if err := middleware.UpdateUser(user); err != nil {
            log.Fatalf("更新用户失败: %v", err)
        }
    }
}
```

#### 缓存预热和更新
缓存预热用于在系统启动或特定时间提前加载数据到缓存中，避免用户请求时缓存未命中的情况，提高系统的响应速度。

```go
// 缓存预热器
type CacheWarmer struct {
    cache       Cache
    db          *sql.DB
    logger      *log.Logger
    warmingKeys []WarmingKey
}

// 预热键配置
type WarmingKey struct {
    Key         string
    Query       string
    Args        []interface{}
    TTL         time.Duration
    Transform   func(interface{}) interface{}
}

// 创建缓存预热器
func NewCacheWarmer(cache Cache, db *sql.DB) *CacheWarmer {
    return &CacheWarmer{
        cache:  cache,
        db:     db,
        logger: log.New(os.Stdout, "[CacheWarmer] ", log.LstdFlags),
    }
}

// 添加预热键
func (w *CacheWarmer) AddWarmingKey(key WarmingKey) {
    w.warmingKeys = append(w.warmingKeys, key)
}

// 执行预热
func (w *CacheWarmer) WarmUp() error {
    w.logger.Println("开始缓存预热...")
    
    for _, wk := range w.warmingKeys {
        w.logger.Printf("预热缓存键: %s", wk.Key)
        
        // 从数据库获取数据
        rows, err := w.db.Query(wk.Query, wk.Args...)
        if err != nil {
            return fmt.Errorf("预热查询失败 [%s]: %w", wk.Key, err)
        }
        
        var data interface{}
        for rows.Next() {
            // 根据查询结果类型进行扫描
            // 这里简化处理，实际应根据查询结果类型来定制
            var id int
            var name string
            if err := rows.Scan(&id, &name); err != nil {
                rows.Close()
                return fmt.Errorf("扫描结果失败 [%s]: %w", wk.Key, err)
            }
            
            // 构造数据
            data = &User{ID: id, Name: name}
            break // 简化示例，只取第一行
        }
        rows.Close()
        
        if data == nil {
            w.logger.Printf("没有数据用于预热 [%s]", wk.Key)
            continue
        }
        
        // 应用转换函数
        if wk.Transform != nil {
            data = wk.Transform(data)
        }
        
        // 设置缓存
        if err := w.cache.Set(wk.Key, data, wk.TTL); err != nil {
            return fmt.Errorf("设置缓存失败 [%s]: %w", wk.Key, err)
        }
        
        w.logger.Printf("成功预热缓存键: %s", wk.Key)
    }
    
    w.logger.Println("缓存预热完成")
    return nil
}

// 设置定时更新
func (w *CacheWarmer) ScheduleUpdates(interval time.Duration) {
    ticker := time.NewTicker(interval)
    go func() {
        for range ticker.C {
            if err := w.WarmUp(); err != nil {
                w.logger.Printf("定时更新缓存失败: %v", err)
            }
        }
    }()
}

// 使用示例
func ExampleCacheWarmer() {
    // 创建缓存和数据库连接
    cache := NewMemoryCache()
    db, _ := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/dbname")
    
    // 创建缓存预热器
    warmer := NewCacheWarmer(cache, db)
    
    // 添加预热键
    warmer.AddWarmingKey(WarmingKey{
        Key:   "user:popular",
        Query: "SELECT id, name FROM users ORDER BY login_count DESC LIMIT 100",
        TTL:   30 * time.Minute,
        Transform: func(data interface{}) interface{} {
            // 转换单个用户为用户列表（实际应用中会更复杂）
            if user, ok := data.(*User); ok {
                return []*User{user}
            }
            return data
        },
    })
    
    warmer.AddWarmingKey(WarmingKey{
        Key:   "product:featured",
        Query: "SELECT id, name FROM products WHERE featured = 1 LIMIT 10",
        TTL:   1 * time.Hour,
    })
    
    // 执行预热
    if err := warmer.WarmUp(); err != nil {
        log.Fatalf("缓存预热失败: %v", err)
    }
    
    // 设置定时更新
    warmer.ScheduleUpdates(15 * time.Minute)
    
    // 应用继续运行...
    select {}
}
```

### 21.7 消息中间件

#### 消息队列中间件
消息队列中间件用于实现异步、解耦和可靠的消息传递，支持系统组件之间的松耦合通信。

```go
// 消息定义
type Message struct {
    ID        string
    Topic     string
    Body      []byte
    Timestamp time.Time
    Headers   map[string]string
}

// 消息队列接口
type MessageQueue interface {
    // 发布消息
    Publish(topic string, message *Message) error
    // 订阅主题
    Subscribe(topic string, handler MessageHandler) (Subscription, error)
    // 关闭队列
    Close() error
}

// 消息处理函数
type MessageHandler func(message *Message) error

// 订阅接口
type Subscription interface {
    // 取消订阅
    Unsubscribe() error
    // 获取主题
    Topic() string
}

// 内存消息队列实现
type InMemoryQueue struct {
    topics    map[string][]MessageHandler
    mu        sync.RWMutex
    msgChan   chan *Message
    closeChan chan struct{}
    wg        sync.WaitGroup
}

// 创建内存消息队列
func NewInMemoryQueue(bufferSize int) *InMemoryQueue {
    q := &InMemoryQueue{
        topics:    make(map[string][]MessageHandler),
        msgChan:   make(chan *Message, bufferSize),
        closeChan: make(chan struct{}),
    }
    
    // 启动消息处理协程
    q.wg.Add(1)
    go q.processMessages()
    
    return q
}

// 处理消息
func (q *InMemoryQueue) processMessages() {
    defer q.wg.Done()
    
    for {
        select {
        case msg := <-q.msgChan:
            q.mu.RLock()
            handlers, ok := q.topics[msg.Topic]
            q.mu.RUnlock()
            
            if ok {
                for _, handler := range handlers {
                    // 避免一个处理器失败影响其他处理器
                    func(h MessageHandler) {
                        defer func() {
                            if r := recover(); r != nil {
                                log.Printf("消息处理器发生panic: %v", r)
                            }
                        }()
                        
                        if err := h(msg); err != nil {
                            log.Printf("处理消息失败: %v", err)
                        }
                    }(handler)
                }
            }
        case <-q.closeChan:
            return
        }
    }
}

// 发布消息
func (q *InMemoryQueue) Publish(topic string, message *Message) error {
    select {
    case <-q.closeChan:
        return fmt.Errorf("消息队列已关闭")
    default:
        if message.ID == "" {
            message.ID = uuid.New().String()
        }
        
        if message.Timestamp.IsZero() {
            message.Timestamp = time.Now()
        }
        
        message.Topic = topic
        
        // 非阻塞发送
        select {
        case q.msgChan <- message:
            return nil
        default:
            return fmt.Errorf("消息队列已满")
        }
    }
}

// 订阅主题
func (q *InMemoryQueue) Subscribe(topic string, handler MessageHandler) (Subscription, error) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    q.topics[topic] = append(q.topics[topic], handler)
    
    return &inMemorySubscription{
        queue: q,
        topic: topic,
        handler: handler,
    }, nil
}

// 关闭队列
func (q *InMemoryQueue) Close() error {
    close(q.closeChan)
    q.wg.Wait()
    close(q.msgChan)
    return nil
}

// 内存订阅实现
type inMemorySubscription struct {
    queue   *InMemoryQueue
    topic   string
    handler MessageHandler
}

// 取消订阅
func (s *inMemorySubscription) Unsubscribe() error {
    s.queue.mu.Lock()
    defer s.queue.mu.Unlock()
    
    handlers := s.queue.topics[s.topic]
    for i, h := range handlers {
        if &h == &s.handler {
            // 从处理器列表中移除
            s.queue.topics[s.topic] = append(handlers[:i], handlers[i+1:]...)
            break
        }
    }
    
    return nil
}

// 获取主题
func (s *inMemorySubscription) Topic() string {
    return s.topic
}

// 使用示例
func ExampleMessageQueue() {
    // 创建消息队列
    queue := NewInMemoryQueue(100)
    defer queue.Close()
    
    // 订阅主题
    sub, err := queue.Subscribe("orders", func(msg *Message) error {
        log.Printf("收到订单消息: %s", string(msg.Body))
        return nil
    })
    if err != nil {
        log.Fatalf("订阅失败: %v", err)
    }
    defer sub.Unsubscribe()
    
    // 发布消息
    msg := &Message{
        Body: []byte(`{"orderId": "12345", "amount": 99.99}`),
        Headers: map[string]string{
            "contentType": "application/json",
        },
    }
    
    if err := queue.Publish("orders", msg); err != nil {
        log.Fatalf("发布消息失败: %v", err)
    }
    
    // 等待消息处理
    time.Sleep(100 * time.Millisecond)
}
```

#### 发布订阅中间件
发布订阅中间件实现了观察者模式，允许发布者和订阅者之间的松耦合通信。

```go
// 事件定义
type Event struct {
    Name       string
    Data       interface{}
    Timestamp  time.Time
    Source     string
}

// 事件处理函数
type EventHandler func(event Event)

// 发布订阅系统
type PubSub struct {
    handlers   map[string][]EventHandler
    mu         sync.RWMutex
    middleware []PubSubMiddleware
}

// 发布订阅中间件
type PubSubMiddleware func(handler EventHandler) EventHandler

// 创建发布订阅系统
func NewPubSub() *PubSub {
    return &PubSub{
        handlers: make(map[string][]EventHandler),
    }
}

// 添加中间件
func (ps *PubSub) Use(middleware ...PubSubMiddleware) {
    ps.middleware = append(ps.middleware, middleware...)
}

// 发布事件
func (ps *PubSub) Publish(event Event) {
    if event.Timestamp.IsZero() {
        event.Timestamp = time.Now()
    }
    
    ps.mu.RLock()
    defer ps.mu.RUnlock()
    
    // 查找处理函数
    handlers, ok := ps.handlers[event.Name]
    if !ok {
        return
    }
    
    // 异步处理事件
    for _, handler := range handlers {
        go func(h EventHandler) {
            defer func() {
                if r := recover(); r != nil {
                    log.Printf("事件处理器发生panic: %v", r)
                }
            }()
            
            h(event)
        }(handler)
    }
}

// 订阅事件
func (ps *PubSub) Subscribe(eventName string, handler EventHandler) func() {
    // 应用中间件
    for i := len(ps.middleware) - 1; i >= 0; i-- {
        handler = ps.middleware[i](handler)
    }
    
    ps.mu.Lock()
    defer ps.mu.Unlock()
    
    ps.handlers[eventName] = append(ps.handlers[eventName], handler)
    
    // 返回取消订阅函数
    return func() {
        ps.mu.Lock()
        defer ps.mu.Unlock()
        
        handlers := ps.handlers[eventName]
        for i, h := range handlers {
            if &h == &handler {
                ps.handlers[eventName] = append(handlers[:i], handlers[i+1:]...)
                break
            }
        }
    }
}

// 常用中间件

// 日志中间件
func LoggingMiddleware(handler EventHandler) EventHandler {
    return func(event Event) {
        start := time.Now()
        log.Printf("开始处理事件: %s", event.Name)
        
        handler(event)
        
        log.Printf("事件处理完成: %s, 耗时: %v", event.Name, time.Since(start))
    }
}

// 重试中间件
func RetryMiddleware(maxRetries int, delay time.Duration) PubSubMiddleware {
    return func(handler EventHandler) EventHandler {
        return func(event Event) {
            var err error
            var success bool
            
            for i := 0; i <= maxRetries; i++ {
                func() {
                    defer func() {
                        if r := recover(); r != nil {
                            err = fmt.Errorf("事件处理器发生panic: %v", r)
                        }
                    }()
                    
                    handler(event)
                    success = true
                }()
                
                if success {
                    break
                }
                
                if i < maxRetries {
                    log.Printf("事件处理失败，将重试 (%d/%d): %v", i+1, maxRetries, err)
                    time.Sleep(delay * time.Duration(i+1))
                }
            }
            
            if !success {
                log.Printf("事件处理最终失败: %v", err)
            }
        }
    }
}

// 使用示例
func ExamplePubSub() {
    // 创建发布订阅系统
    pubsub := NewPubSub()
    
    // 添加中间件
    pubsub.Use(
        LoggingMiddleware,
        RetryMiddleware(3, 100*time.Millisecond),
    )
    
    // 订阅事件
    unsubscribe := pubsub.Subscribe("user.created", func(event Event) {
        user, ok := event.Data.(map[string]interface{})
        if ok {
            log.Printf("用户创建事件: ID=%v, Name=%v", user["id"], user["name"])
        }
    })
    defer unsubscribe()
    
    // 发布事件
    pubsub.Publish(Event{
        Name: "user.created",
        Data: map[string]interface{}{
            "id":   123,
            "name": "张三",
        },
        Source: "user-service",
    })
    
    // 等待事件处理
    time.Sleep(500 * time.Millisecond)
}
```

#### 消息路由中间件
消息路由中间件基于消息的内容或元数据将消息路由到不同的处理器或目的地。

```go
// 路由规则
type RoutingRule struct {
    Name       string
    Condition  func(message *Message) bool
    Handler    MessageHandler
}

// 消息路由器
type MessageRouter struct {
    rules      []RoutingRule
    defaultHandler MessageHandler
    mu         sync.RWMutex
}

// 创建消息路由器
func NewMessageRouter() *MessageRouter {
    return &MessageRouter{
        rules: make([]RoutingRule, 0),
    }
}

// 添加路由规则
func (r *MessageRouter) AddRule(rule RoutingRule) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.rules = append(r.rules, rule)
}

// 设置默认处理器
func (r *MessageRouter) SetDefaultHandler(handler MessageHandler) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.defaultHandler = handler
}

// 路由消息
func (r *MessageRouter) Route(message *Message) error {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    // 按规则匹配
    for _, rule := range r.rules {
        if rule.Condition(message) {
            return rule.Handler(message)
        }
    }
    
    // 使用默认处理器
    if r.defaultHandler != nil {
        return r.defaultHandler(message)
    }
    
    return fmt.Errorf("没有匹配的路由规则: %s", message.Topic)
}

// 创建主题路由器
func NewTopicRouter(queue MessageQueue) *MessageRouter {
    router := NewMessageRouter()
    
    // 订阅所有消息并路由
    _, err := queue.Subscribe("#", func(message *Message) error {
        return router.Route(message)
    })
    
    if err != nil {
        log.Fatalf("订阅消息失败: %v", err)
    }
    
    return router
}

// 使用示例
func ExampleMessageRouter() {
    // 创建消息队列
    queue := NewInMemoryQueue(100)
    defer queue.Close()
    
    // 创建消息路由器
    router := NewMessageRouter()
    
    // 添加路由规则
    
    // 处理订单创建
    router.AddRule(RoutingRule{
        Name: "订单创建",
        Condition: func(msg *Message) bool {
            return msg.Topic == "orders" && 
                   msg.Headers["action"] == "create"
        },
        Handler: func(msg *Message) error {
            log.Printf("处理订单创建: %s", string(msg.Body))
            return nil
        },
    })
    
    // 处理订单支付
    router.AddRule(RoutingRule{
        Name: "订单支付",
        Condition: func(msg *Message) bool {
            return msg.Topic == "orders" && 
                   msg.Headers["action"] == "payment"
        },
        Handler: func(msg *Message) error {
            log.Printf("处理订单支付: %s", string(msg.Body))
            return nil
        },
    })
    
    // 设置默认处理器
    router.SetDefaultHandler(func(msg *Message) error {
        log.Printf("未知消息: %s - %s", msg.Topic, string(msg.Body))
        return nil
    })
    
    // 订阅消息并路由
    _, err := queue.Subscribe("orders", func(msg *Message) error {
        return router.Route(msg)
    })
    if err != nil {
        log.Fatalf("订阅消息失败: %v", err)
    }
    
    // 发布订单创建消息
    createMsg := &Message{
        Body: []byte(`{"orderId": "12345", "amount": 99.99}`),
        Headers: map[string]string{
            "contentType": "application/json",
            "action": "create",
        },
    }
    queue.Publish("orders", createMsg)
    
    // 发布订单支付消息
    paymentMsg := &Message{
        Body: []byte(`{"orderId": "12345", "paymentId": "p-789"}`),
        Headers: map[string]string{
            "contentType": "application/json",
            "action": "payment",
        },
    }
    queue.Publish("orders", paymentMsg)
    
    // 等待消息处理
    time.Sleep(100 * time.Millisecond)
}
```

#### 消息可靠性保证
消息可靠性中间件确保消息不会丢失，并且能够正确处理，即使在系统故障或网络问题的情况下。

```go
// 可靠消息队列
type ReliableMessageQueue struct {
    inner      MessageQueue
    storage    MessageStorage
    retryQueue *MessageRetryQueue
}

// 消息存储接口
type MessageStorage interface {
    // 保存消息
    SaveMessage(message *Message) error
    // 标记消息为已处理
    MarkAsProcessed(messageID string) error
    // 获取未处理的消息
    GetUnprocessedMessages() ([]*Message, error)
    // 关闭存储
    Close() error
}

// 消息重试队列
type MessageRetryQueue struct {
    messages    map[string]*retryMessage
    maxRetries  int
    retryDelay  time.Duration
    queue       MessageQueue
    mu          sync.Mutex
    closeChan   chan struct{}
    wg          sync.WaitGroup
}

// 重试消息
type retryMessage struct {
    message    *Message
    retryCount int
    nextRetry  time.Time
}

// 创建可靠消息队列
func NewReliableMessageQueue(inner MessageQueue, storage MessageStorage) *ReliableMessageQueue {
    rmq := &ReliableMessageQueue{
        inner:   inner,
        storage: storage,
        retryQueue: &MessageRetryQueue{
            messages:   make(map[string]*retryMessage),
            maxRetries: 5,
            retryDelay: 5 * time.Second,
            queue:      inner,
            closeChan:  make(chan struct{}),
        },
    }
    
    // 启动重试队列
    rmq.retryQueue.start()
    
    // 恢复未处理的消息
    rmq.recoverUnprocessedMessages()
    
    return rmq
}

// 恢复未处理的消息
func (q *ReliableMessageQueue) recoverUnprocessedMessages() {
    messages, err := q.storage.GetUnprocessedMessages()
    if err != nil {
        log.Printf("获取未处理消息失败: %v", err)
        return
    }
    
    log.Printf("恢复 %d 条未处理消息", len(messages))
    
    for _, msg := range messages {
        // 重新发布消息
        go func(m *Message) {
            if err := q.inner.Publish(m.Topic, m); err != nil {
                log.Printf("重新发布消息失败: %v", err)
                q.retryQueue.addMessage(m)
            }
        }(msg)
    }
}

// 发布消息
func (q *ReliableMessageQueue) Publish(topic string, message *Message) error {
    // 保存消息到存储
    if err := q.storage.SaveMessage(message); err != nil {
        return fmt.Errorf("保存消息失败: %w", err)
    }
    
    // 发布消息
    if err := q.inner.Publish(topic, message); err != nil {
        // 发布失败，加入重试队列
        q.retryQueue.addMessage(message)
        return fmt.Errorf("发布消息失败，已加入重试队列: %w", err)
    }
    
    return nil
}

// 订阅主题
func (q *ReliableMessageQueue) Subscribe(topic string, handler MessageHandler) (Subscription, error) {
    // 包装处理函数，添加确认逻辑
    wrappedHandler := func(message *Message) error {
        err := handler(message)
        if err == nil {
            // 消息处理成功，标记为已处理
            if err := q.storage.MarkAsProcessed(message.ID); err != nil {
                log.Printf("标记消息为已处理失败: %v", err)
            }
        } else {
            // 处理失败，加入重试队列
            q.retryQueue.addMessage(message)
        }
        return err
    }
    
    return q.inner.Subscribe(topic, wrappedHandler)
}

// 关闭队列
func (q *ReliableMessageQueue) Close() error {
    // 关闭重试队列
    close(q.retryQueue.closeChan)
    q.retryQueue.wg.Wait()
    
    // 关闭存储
    if err := q.storage.Close(); err != nil {
        log.Printf("关闭存储失败: %v", err)
    }
    
    // 关闭内部队列
    return q.inner.Close()
}

// 启动重试队列
func (q *MessageRetryQueue) start() {
    q.wg.Add(1)
    go func() {
        defer q.wg.Done()
        
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                q.retryMessages()
            case <-q.closeChan:
                return
            }
        }
    }()
}

// 添加消息到重试队列
func (q *MessageRetryQueue) addMessage(message *Message) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    retryMsg, exists := q.messages[message.ID]
    if !exists {
        retryMsg = &retryMessage{
            message:    message,
            retryCount: 0,
        }
        q.messages[message.ID] = retryMsg
    }
    
    retryMsg.retryCount++
    retryMsg.nextRetry = time.Now().Add(q.retryDelay * time.Duration(retryMsg.retryCount))
}

// 重试消息
func (q *MessageRetryQueue) retryMessages() {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    now := time.Now()
    
    for id, retryMsg := range q.messages {
        if retryMsg.nextRetry.Before(now) {
            if retryMsg.retryCount > q.maxRetries {
                log.Printf("消息重试次数超过上限，放弃重试: %s", id)
                delete(q.messages, id)
                continue
            }
            
            // 重新发布消息
            go func(m *Message) {
                if err := q.queue.Publish(m.Topic, m); err != nil {
                    log.Printf("重试发布消息失败: %v", err)
                } else {
                    q.mu.Lock()
                    delete(q.messages, m.ID)
                    q.mu.Unlock()
                }
            }(retryMsg.message)
        }
    }
}

// 文件存储实现
type FileMessageStorage struct {
    dir         string
    pendingDir  string
    processedDir string
    mu          sync.Mutex
}

// 创建文件消息存储
func NewFileMessageStorage(baseDir string) (*FileMessageStorage, error) {
    pendingDir := filepath.Join(baseDir, "pending")
    processedDir := filepath.Join(baseDir, "processed")
    
    // 创建目录
    for _, dir := range []string{baseDir, pendingDir, processedDir} {
        if err := os.MkdirAll(dir, 0755); err != nil {
            return nil, fmt.Errorf("创建目录失败: %w", err)
        }
    }
    
    return &FileMessageStorage{
        dir:         baseDir,
        pendingDir:  pendingDir,
        processedDir: processedDir,
    }, nil
}

// 保存消息
func (s *FileMessageStorage) SaveMessage(message *Message) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 确保消息有ID
    if message.ID == "" {
        message.ID = uuid.New().String()
    }
    
    // 序列化消息
    data, err := json.Marshal(message)
    if err != nil {
        return fmt.Errorf("序列化消息失败: %w", err)
    }
    
    // 保存到文件
    filename := filepath.Join(s.pendingDir, message.ID+".json")
    if err := ioutil.WriteFile(filename, data, 0644); err != nil {
        return fmt.Errorf("写入消息文件失败: %w", err)
    }
    
    return nil
}

// 标记消息为已处理
func (s *FileMessageStorage) MarkAsProcessed(messageID string) error {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 源文件和目标文件路径
    srcPath := filepath.Join(s.pendingDir, messageID+".json")
    dstPath := filepath.Join(s.processedDir, messageID+".json")
    
    // 移动文件
    if err := os.Rename(srcPath, dstPath); err != nil {
        return fmt.Errorf("移动消息文件失败: %w", err)
    }
    
    return nil
}

// 获取未处理的消息
func (s *FileMessageStorage) GetUnprocessedMessages() ([]*Message, error) {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    // 读取目录中的所有文件
    files, err := ioutil.ReadDir(s.pendingDir)
    if err != nil {
        return nil, fmt.Errorf("读取目录失败: %w", err)
    }
    
    var messages []*Message
    
    for _, file := range files {
        if filepath.Ext(file.Name()) != ".json" {
            continue
        }
        
        // 读取文件内容
        data, err := ioutil.ReadFile(filepath.Join(s.pendingDir, file.Name()))
        if err != nil {
            log.Printf("读取消息文件失败: %v", err)
            continue
        }
        
        // 反序列化消息
        var message Message
        if err := json.Unmarshal(data, &message); err != nil {
            log.Printf("反序列化消息失败: %v", err)
            continue
        }
        
        messages = append(messages, &message)
    }
    
    return messages, nil
}

// 关闭存储
func (s *FileMessageStorage) Close() error {
    return nil
}

// 使用示例
func ExampleReliableMessageQueue() {
    // 创建消息存储
    storage, err := NewFileMessageStorage("/tmp/message-queue")
    if err != nil {
        log.Fatalf("创建消息存储失败: %v", err)
    }
    
    // 创建内存消息队列
    innerQueue := NewInMemoryQueue(100)
    
    // 创建可靠消息队列
    queue := NewReliableMessageQueue(innerQueue, storage)
    defer queue.Close()
    
    // 订阅主题
    sub, err := queue.Subscribe("orders", func(msg *Message) error {
        log.Printf("处理订单消息: %s", string(msg.Body))
        return nil
    })
    if err != nil {
        log.Fatalf("订阅失败: %v", err)
    }
    defer sub.Unsubscribe()
    
    // 发布消息
    msg := &Message{
        Body: []byte(`{"orderId": "12345", "amount": 99.99}`),
        Headers: map[string]string{
            "contentType": "application/json",
        },
    }
    
    if err := queue.Publish("orders", msg); err != nil {
        log.Printf("发布消息警告: %v", err)
    }
    
    // 等待消息处理
    time.Sleep(1 * time.Second)
}
```

### 21.8 安全中间件

#### 身份验证中间件
身份验证中间件负责验证请求的发起者身份，确保只有授权用户能够访问系统资源。

```go
// JWT验证中间件
type JWTMiddleware struct {
    secret        []byte
    tokenLookup   string    // 查找令牌的位置，如"header:Authorization"
    authScheme    string    // 认证方案，如"Bearer"
    signingMethod jwt.SigningMethod
}

// JWT配置
type JWTConfig struct {
    Secret        string
    TokenLookup   string
    AuthScheme    string
    SigningMethod string
}

// 创建JWT中间件
func NewJWTMiddleware(config JWTConfig) *JWTMiddleware {
    if config.TokenLookup == "" {
        config.TokenLookup = "header:Authorization"
    }
    
    if config.AuthScheme == "" {
        config.AuthScheme = "Bearer"
    }
    
    signingMethod := jwt.SigningMethodHS256
    if config.SigningMethod == "HS512" {
        signingMethod = jwt.SigningMethodHS512
    } else if config.SigningMethod == "HS384" {
        signingMethod = jwt.SigningMethodHS384
    }
    
    return &JWTMiddleware{
        secret:        []byte(config.Secret),
        tokenLookup:   config.TokenLookup,
        authScheme:    config.AuthScheme,
        signingMethod: signingMethod,
    }
}

// JWT中间件处理函数
func (m *JWTMiddleware) HandlerFunc() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 获取令牌
            token, err := m.extractToken(r)
            if err != nil {
                http.Error(w, "未授权访问", http.StatusUnauthorized)
                return
            }
            
            // 验证令牌
            claims, err := m.validateToken(token)
            if err != nil {
                http.Error(w, "无效的令牌", http.StatusUnauthorized)
                return
            }
            
            // 将用户信息放入上下文
            ctx := context.WithValue(r.Context(), "user", claims)
            
            // 调用下一个处理器
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}

// 提取令牌
func (m *JWTMiddleware) extractToken(r *http.Request) (string, error) {
    parts := strings.Split(m.tokenLookup, ":")
    if len(parts) != 2 {
        return "", fmt.Errorf("无效的令牌查找配置")
    }
    
    switch parts[0] {
    case "header":
        authHeader := r.Header.Get(parts[1])
        if authHeader == "" {
            return "", fmt.Errorf("未找到认证头")
        }
        
        if m.authScheme != "" {
            authParts := strings.SplitN(authHeader, " ", 2)
            if len(authParts) != 2 || authParts[0] != m.authScheme {
                return "", fmt.Errorf("无效的认证方案")
            }
            return authParts[1], nil
        }
        
        return authHeader, nil
        
    case "query":
        token := r.URL.Query().Get(parts[1])
        if token == "" {
            return "", fmt.Errorf("未找到查询参数")
        }
        return token, nil
        
    case "cookie":
        cookie, err := r.Cookie(parts[1])
        if err != nil {
            return "", fmt.Errorf("未找到Cookie: %w", err)
        }
        return cookie.Value, nil
        
    default:
        return "", fmt.Errorf("不支持的令牌查找方式")
    }
}

// 验证令牌
func (m *JWTMiddleware) validateToken(tokenString string) (jwt.MapClaims, error) {
    // 解析令牌
    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
        // 验证签名方法
        if token.Method.Alg() != m.signingMethod.Alg() {
            return nil, fmt.Errorf("无效的签名方法")
        }
        return m.secret, nil
    })
    
    if err != nil {
        return nil, err
    }
    
    // 验证令牌是否有效
    if !token.Valid {
        return nil, fmt.Errorf("无效的令牌")
    }
    
    // 获取声明
    claims, ok := token.Claims.(jwt.MapClaims)
    if !ok {
        return nil, fmt.Errorf("无效的声明")
    }
    
    // 验证过期时间
    if exp, ok := claims["exp"].(float64); ok {
        if time.Now().Unix() > int64(exp) {
            return nil, fmt.Errorf("令牌已过期")
        }
    }
    
    return claims, nil
}

// 生成令牌
func (m *JWTMiddleware) GenerateToken(claims jwt.MapClaims) (string, error) {
    token := jwt.NewWithClaims(m.signingMethod, claims)
    return token.SignedString(m.secret)
}

// 使用示例
func ExampleJWTMiddleware() {
    // 创建JWT中间件
    jwtMiddleware := NewJWTMiddleware(JWTConfig{
        Secret: "your-secret-key",
    })
    
    // 创建HTTP处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从上下文获取用户信息
        claims := r.Context().Value("user").(jwt.MapClaims)
        
        // 使用用户信息
        userID := claims["sub"].(string)
        
        // 响应
        w.Header().Set("Content-Type", "application/json")
        fmt.Fprintf(w, `{"message": "Hello, %s"}`, userID)
    })
    
    // 应用JWT中间件
    http.Handle("/api/protected", jwtMiddleware.HandlerFunc()(handler))
    
    // 创建登录处理器
    http.HandleFunc("/api/login", func(w http.ResponseWriter, r *http.Request) {
        // 实际应用中应验证用户名和密码
        
        // 创建令牌
        claims := jwt.MapClaims{
            "sub": "user123",
            "name": "John Doe",
            "exp": time.Now().Add(24 * time.Hour).Unix(),
        }
        
        token, err := jwtMiddleware.GenerateToken(claims)
        if err != nil {
            http.Error(w, "生成令牌失败", http.StatusInternalServerError)
            return
        }
        
        // 返回令牌
        w.Header().Set("Content-Type", "application/json")
        fmt.Fprintf(w, `{"token": "%s"}`, token)
    })
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 权限控制中间件
权限控制中间件负责检查用户是否有权限执行特定操作或访问特定资源。

```go
// 角色类型
type Role string

// 预定义角色
const (
    RoleAdmin   Role = "admin"
    RoleUser    Role = "user"
    RoleGuest   Role = "guest"
)

// 权限类型
type Permission string

// 预定义权限
const (
    PermissionRead   Permission = "read"
    PermissionWrite  Permission = "write"
    PermissionDelete Permission = "delete"
    PermissionAdmin  Permission = "admin"
)

// 角色-权限映射
type RolePermissionMap map[Role][]Permission

// RBAC中间件
type RBACMiddleware struct {
    rolePermissions RolePermissionMap
}

// 创建RBAC中间件
func NewRBACMiddleware() *RBACMiddleware {
    return &RBACMiddleware{
        rolePermissions: make(RolePermissionMap),
    }
}

// 添加角色权限
func (m *RBACMiddleware) AddRolePermission(role Role, permissions ...Permission) {
    m.rolePermissions[role] = append(m.rolePermissions[role], permissions...)
}

// 检查角色是否具有权限
func (m *RBACMiddleware) HasPermission(role Role, permission Permission) bool {
    permissions, ok := m.rolePermissions[role]
    if !ok {
        return false
    }
    
    for _, p := range permissions {
        if p == permission || p == PermissionAdmin {
            return true
        }
    }
    
    return false
}

// 需要权限的中间件
func (m *RBACMiddleware) RequirePermission(permission Permission) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 从上下文获取用户信息
            claims, ok := r.Context().Value("user").(jwt.MapClaims)
            if !ok {
                http.Error(w, "未授权访问", http.StatusUnauthorized)
                return
            }
            
            // 获取用户角色
            roleStr, ok := claims["role"].(string)
            if !ok {
                http.Error(w, "无效的用户角色", http.StatusForbidden)
                return
            }
            
            role := Role(roleStr)
            
            // 检查权限
            if !m.HasPermission(role, permission) {
                http.Error(w, "权限不足", http.StatusForbidden)
                return
            }
            
            // 调用下一个处理器
            next.ServeHTTP(w, r)
        })
    }
}

// 使用示例
func ExampleRBACMiddleware() {
    // 创建RBAC中间件
    rbac := NewRBACMiddleware()
    
    // 配置角色权限
    rbac.AddRolePermission(RoleAdmin, PermissionAdmin)
    rbac.AddRolePermission(RoleUser, PermissionRead, PermissionWrite)
    rbac.AddRolePermission(RoleGuest, PermissionRead)
    
    // 创建JWT中间件
    jwtMiddleware := NewJWTMiddleware(JWTConfig{
        Secret: "your-secret-key",
    })
    
    // 创建HTTP处理器
    getHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("读取数据"))
    })
    
    postHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("写入数据"))
    })
    
    deleteHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("删除数据"))
    })
    
    // 应用中间件
    http.Handle("/api/data", jwtMiddleware.HandlerFunc()(
        rbac.RequirePermission(PermissionRead)(getHandler)))
    
    http.Handle("/api/data/create", jwtMiddleware.HandlerFunc()(
        rbac.RequirePermission(PermissionWrite)(postHandler)))
    
    http.Handle("/api/data/delete", jwtMiddleware.HandlerFunc()(
        rbac.RequirePermission(PermissionDelete)(deleteHandler)))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 加密解密中间件
加密解密中间件负责保护敏感数据的安全性，防止数据在传输和存储过程中被未授权访问。

```go
// 加密服务
type EncryptionService struct {
    key []byte
}

// 创建加密服务
func NewEncryptionService(key string) *EncryptionService {
    // 使用SHA-256生成固定长度的密钥
    hasher := sha256.New()
    hasher.Write([]byte(key))
    
    return &EncryptionService{
        key: hasher.Sum(nil),
    }
}

// 加密数据
func (s *EncryptionService) Encrypt(data []byte) ([]byte, error) {
    // 创建密码块
    block, err := aes.NewCipher(s.key)
    if err != nil {
        return nil, fmt.Errorf("创建密码块失败: %w", err)
    }
    
    // 创建GCM
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, fmt.Errorf("创建GCM失败: %w", err)
    }
    
    // 创建随机nonce
    nonce := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
        return nil, fmt.Errorf("创建nonce失败: %w", err)
    }
    
    // 加密数据
    ciphertext := gcm.Seal(nonce, nonce, data, nil)
    
    return ciphertext, nil
}

// 解密数据
func (s *EncryptionService) Decrypt(ciphertext []byte) ([]byte, error) {
    // 创建密码块
    block, err := aes.NewCipher(s.key)
    if err != nil {
        return nil, fmt.Errorf("创建密码块失败: %w", err)
    }
    
    // 创建GCM
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, fmt.Errorf("创建GCM失败: %w", err)
    }
    
    // 检查密文长度
    if len(ciphertext) < gcm.NonceSize() {
        return nil, fmt.Errorf("密文长度不足")
    }
    
    // 分离nonce和密文
    nonce, ciphertext := ciphertext[:gcm.NonceSize()], ciphertext[gcm.NonceSize():]
    
    // 解密数据
    plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
    if err != nil {
        return nil, fmt.Errorf("解密失败: %w", err)
    }
    
    return plaintext, nil
}

// 加密中间件
func EncryptionMiddleware(service *EncryptionService) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 如果是POST/PUT/PATCH请求，解密请求体
            if r.Method == http.MethodPost || r.Method == http.MethodPut || r.Method == http.MethodPatch {
                // 检查内容类型
                if !strings.Contains(r.Header.Get("Content-Type"), "application/octet-stream") {
                    next.ServeHTTP(w, r)
                    return
                }
                
                // 读取请求体
                body, err := ioutil.ReadAll(r.Body)
                r.Body.Close()
                if err != nil {
                    http.Error(w, "读取请求体失败", http.StatusBadRequest)
                    return
                }
                
                // 解密请求体
                decrypted, err := service.Decrypt(body)
                if err != nil {
                    http.Error(w, "解密请求体失败", http.StatusBadRequest)
                    return
                }
                
                // 替换请求体
                r.Body = ioutil.NopCloser(bytes.NewReader(decrypted))
                r.ContentLength = int64(len(decrypted))
                r.Header.Set("Content-Type", "application/json")
            }
            
            // 包装ResponseWriter以加密响应
            ew := &encryptionResponseWriter{
                ResponseWriter: w,
                service:        service,
            }
            
            next.ServeHTTP(ew, r)
        })
    }
}

// 加密响应写入器
type encryptionResponseWriter struct {
    http.ResponseWriter
    service *EncryptionService
    buf     bytes.Buffer
}

// 写入响应
func (w *encryptionResponseWriter) Write(b []byte) (int, error) {
    return w.buf.Write(b)
}

// 完成响应
func (w *encryptionResponseWriter) WriteHeader(statusCode int) {
    // 如果需要加密
    if strings.Contains(w.Header().Get("Content-Type"), "application/json") && w.buf.Len() > 0 {
        // 加密数据
        encrypted, err := w.service.Encrypt(w.buf.Bytes())
        if err != nil {
            w.ResponseWriter.WriteHeader(http.StatusInternalServerError)
            w.ResponseWriter.Write([]byte("加密响应失败"))
            return
        }
        
        // 设置头部
        w.Header().Set("Content-Type", "application/octet-stream")
        w.Header().Set("Content-Length", strconv.Itoa(len(encrypted)))
        
        // 写入状态码和数据
        w.ResponseWriter.WriteHeader(statusCode)
        w.ResponseWriter.Write(encrypted)
    } else {
        // 不需要加密，直接写入
        w.ResponseWriter.WriteHeader(statusCode)
        if w.buf.Len() > 0 {
            w.ResponseWriter.Write(w.buf.Bytes())
        }
    }
}

// 使用示例
func ExampleEncryptionMiddleware() {
    // 创建加密服务
    encService := NewEncryptionService("your-secret-key")
    
    // 创建HTTP处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 处理请求
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"message": "Hello, World!"}`))
    })
    
    // 应用加密中间件
    http.Handle("/api/secure", EncryptionMiddleware(encService)(handler))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 防护攻击中间件
防护攻击中间件用于保护应用程序免受常见的安全攻击，如XSS、CSRF、SQL注入等。

```go
// 安全头部中间件
func SecurityHeadersMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 防止点击劫持
        w.Header().Set("X-Frame-Options", "DENY")
        
        // 防止MIME类型嗅探
        w.Header().Set("X-Content-Type-Options", "nosniff")
        
        // 启用XSS过滤器
        w.Header().Set("X-XSS-Protection", "1; mode=block")
        
        // 内容安全策略
        w.Header().Set("Content-Security-Policy", "default-src 'self'")
        
        // HTTP严格传输安全
        w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")
        
        // 引荐来源策略
        w.Header().Set("Referrer-Policy", "no-referrer-when-downgrade")
        
        // 调用下一个处理器
        next.ServeHTTP(w, r)
    })
}

// CSRF保护中间件
type CSRFMiddleware struct {
    secret    []byte
    cookieName string
    headerName string
    secure     bool
}

// 创建CSRF中间件
func NewCSRFMiddleware(secret string, secure bool) *CSRFMiddleware {
    return &CSRFMiddleware{
        secret:     []byte(secret),
        cookieName: "csrf_token",
        headerName: "X-CSRF-Token",
        secure:     secure,
    }
}

// CSRF中间件处理函数
func (m *CSRFMiddleware) HandlerFunc() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 对于非修改请求，只生成令牌
            if r.Method == http.MethodGet || r.Method == http.MethodHead || r.Method == http.MethodOptions {
                // 生成CSRF令牌
                token := m.generateToken(r)
                
                // 设置Cookie
                http.SetCookie(w, &http.Cookie{
                    Name:     m.cookieName,
                    Value:    token,
                    Path:     "/",
                    HttpOnly: true,
                    Secure:   m.secure,
                    SameSite: http.SameSiteStrictMode,
                })
                
                // 调用下一个处理器
                next.ServeHTTP(w, r)
                return
            }
            
            // 对于修改请求，验证令牌
            cookie, err := r.Cookie(m.cookieName)
            if err != nil {
                http.Error(w, "CSRF令牌缺失", http.StatusForbidden)
                return
            }
            
            // 从头部获取令牌
            token := r.Header.Get(m.headerName)
            if token == "" {
                http.Error(w, "CSRF令牌缺失", http.StatusForbidden)
                return
            }
            
            // 验证令牌
            if !m.validateToken(cookie.Value, token) {
                http.Error(w, "CSRF令牌无效", http.StatusForbidden)
                return
            }
            
            // 调用下一个处理器
            next.ServeHTTP(w, r)
        })
    }
}

// 生成CSRF令牌
func (m *CSRFMiddleware) generateToken(r *http.Request) string {
    // 创建随机令牌
    tokenBytes := make([]byte, 32)
    if _, err := io.ReadFull(rand.Reader, tokenBytes); err != nil {
        // 如果随机数生成失败，使用时间戳和IP地址
        hash := sha256.New()
        hash.Write([]byte(r.RemoteAddr))
        hash.Write([]byte(time.Now().String()))
        tokenBytes = hash.Sum(nil)
    }
    
    // 编码令牌
    return base64.StdEncoding.EncodeToString(tokenBytes)
}

// 验证CSRF令牌
func (m *CSRFMiddleware) validateToken(cookieToken, headerToken string) bool {
    return subtle.ConstantTimeCompare([]byte(cookieToken), []byte(headerToken)) == 1
}

// 速率限制中间件
type RateLimiterMiddleware struct {
    limiter  *rate.Limiter
    ipLimiters map[string]*rate.Limiter
    mu       sync.Mutex
    perIP    bool
    burst    int
    rps      rate.Limit
}

// 创建速率限制中间件
func NewRateLimiterMiddleware(rps float64, burst int, perIP bool) *RateLimiterMiddleware {
    var limiter *rate.Limiter
    if !perIP {
        limiter = rate.NewLimiter(rate.Limit(rps), burst)
    }
    
    return &RateLimiterMiddleware{
        limiter:    limiter,
        ipLimiters: make(map[string]*rate.Limiter),
        perIP:      perIP,
        burst:      burst,
        rps:        rate.Limit(rps),
    }
}

// 获取IP限制器
func (m *RateLimiterMiddleware) getLimiterForIP(ip string) *rate.Limiter {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    limiter, exists := m.ipLimiters[ip]
    if !exists {
        limiter = rate.NewLimiter(m.rps, m.burst)
        m.ipLimiters[ip] = limiter
    }
    
    return limiter
}

// 速率限制中间件处理函数
func (m *RateLimiterMiddleware) HandlerFunc() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            var limiter *rate.Limiter
            
            if m.perIP {
                // 获取客户端IP
                ip := r.RemoteAddr
                if forwardedFor := r.Header.Get("X-Forwarded-For"); forwardedFor != "" {
                    ips := strings.Split(forwardedFor, ",")
                    ip = strings.TrimSpace(ips[0])
                }
                
                limiter = m.getLimiterForIP(ip)
            } else {
                limiter = m.limiter
            }
            
            // 检查是否允许请求
            if !limiter.Allow() {
                http.Error(w, "请求过多，请稍后再试", http.StatusTooManyRequests)
                return
            }
            
            // 调用下一个处理器
            next.ServeHTTP(w, r)
        })
    }
}

// 使用示例
func ExampleSecurityMiddleware() {
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello, World!"))
    })
    
    // 创建CSRF中间件
    csrfMiddleware := NewCSRFMiddleware("your-csrf-secret", true)
    
    // 创建速率限制中间件
    rateLimiter := NewRateLimiterMiddleware(10, 5, true)
    
    // 应用安全中间件
    secureHandler := SecurityHeadersMiddleware(
        csrfMiddleware.HandlerFunc()(
            rateLimiter.HandlerFunc()(
                handler,
            ),
        ),
    )
    
    http.Handle("/api/secure", secureHandler)
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### 21.9 监控和观测中间件

#### 指标收集中间件
指标收集中间件用于收集应用程序的运行指标，如请求数量、响应时间、错误率等，帮助开发者了解系统的运行状况。

```go
// 指标收集器
type MetricsCollector struct {
    requestCount      *atomic.Int64
    requestDurations  []time.Duration
    errorCount        *atomic.Int64
    mu                sync.RWMutex
    startTime         time.Time
    statusCounts      map[int]*atomic.Int64
}

// 创建指标收集器
func NewMetricsCollector() *MetricsCollector {
    return &MetricsCollector{
        requestCount:     &atomic.Int64{},
        requestDurations: make([]time.Duration, 0),
        errorCount:       &atomic.Int64{},
        startTime:        time.Now(),
        statusCounts:     make(map[int]*atomic.Int64),
    }
}

// 记录请求
func (c *MetricsCollector) RecordRequest(duration time.Duration, statusCode int) {
    c.requestCount.Add(1)
    
    c.mu.Lock()
    c.requestDurations = append(c.requestDurations, duration)
    c.mu.Unlock()
    
    if statusCode >= 400 {
        c.errorCount.Add(1)
    }
    
    // 记录状态码数量
    c.mu.RLock()
    counter, ok := c.statusCounts[statusCode]
    c.mu.RUnlock()
    
    if !ok {
        c.mu.Lock()
        counter = &atomic.Int64{}
        c.statusCounts[statusCode] = counter
        c.mu.Unlock()
    }
    
    counter.Add(1)
}

// 获取总请求数
func (c *MetricsCollector) RequestCount() int64 {
    return c.requestCount.Load()
}

// 获取错误数
func (c *MetricsCollector) ErrorCount() int64 {
    return c.errorCount.Load()
}

// 获取平均请求耗时
func (c *MetricsCollector) AverageRequestDuration() time.Duration {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    if len(c.requestDurations) == 0 {
        return 0
    }
    
    var total time.Duration
    for _, d := range c.requestDurations {
        total += d
    }
    
    return total / time.Duration(len(c.requestDurations))
}

// 获取状态码计数
func (c *MetricsCollector) StatusCodeCount(code int) int64 {
    c.mu.RLock()
    counter, ok := c.statusCounts[code]
    c.mu.RUnlock()
    
    if !ok {
        return 0
    }
    
    return counter.Load()
}

// 获取指标摘要
func (c *MetricsCollector) Summary() map[string]interface{} {
    return map[string]interface{}{
        "request_count":           c.RequestCount(),
        "error_count":             c.ErrorCount(),
        "average_request_duration": c.AverageRequestDuration().String(),
        "uptime":                  time.Since(c.startTime).String(),
        "status_codes":            c.getStatusCodeCounts(),
    }
}

// 获取状态码计数映射
func (c *MetricsCollector) getStatusCodeCounts() map[int]int64 {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    result := make(map[int]int64)
    for code, counter := range c.statusCounts {
        result[code] = counter.Load()
    }
    
    return result
}

// 指标中间件
func MetricsMiddleware(collector *MetricsCollector) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            startTime := time.Now()
            
            // 创建响应记录器
            recorder := &responseRecorder{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
            }
            
            // 处理请求
            next.ServeHTTP(recorder, r)
            
            // 记录指标
            duration := time.Since(startTime)
            collector.RecordRequest(duration, recorder.statusCode)
        })
    }
}

// 响应记录器
type responseRecorder struct {
    http.ResponseWriter
    statusCode int
}

// 重写WriteHeader方法以记录状态码
func (r *responseRecorder) WriteHeader(statusCode int) {
    r.statusCode = statusCode
    r.ResponseWriter.WriteHeader(statusCode)
}

// 指标导出处理器
func MetricsHandler(collector *MetricsCollector) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        summary := collector.Summary()
        
        // 序列化为JSON
        data, err := json.Marshal(summary)
        if err != nil {
            http.Error(w, "序列化指标失败", http.StatusInternalServerError)
            return
        }
        
        w.Header().Set("Content-Type", "application/json")
        w.Write(data)
    })
}

// 使用示例
func ExampleMetricsMiddleware() {
    // 创建指标收集器
    collector := NewMetricsCollector()
    
    // 创建指标中间件
    metricsMiddleware := MetricsMiddleware(collector)
    
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        w.Write([]byte("Hello, World!"))
    })
    
    // 应用中间件
    http.Handle("/api/hello", metricsMiddleware(handler))
    
    // 导出指标
    http.Handle("/metrics", MetricsHandler(collector))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 链路追踪中间件
链路追踪中间件用于跟踪分布式系统中请求的完整路径，帮助开发者理解和优化系统性能，定位问题。

```go
// 追踪上下文
type TraceContext struct {
    TraceID      string
    SpanID       string
    ParentSpanID string
    Sampled      bool
    Tags         map[string]string
    StartTime    time.Time
}

// 生成追踪ID
func GenerateTraceID() string {
    id := make([]byte, 16)
    rand.Read(id)
    return hex.EncodeToString(id)
}

// 生成Span ID
func GenerateSpanID() string {
    id := make([]byte, 8)
    rand.Read(id)
    return hex.EncodeToString(id)
}

// 追踪中间件
func TracingMiddleware(serviceName string) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            var traceContext TraceContext
            
            // 从请求头中提取追踪信息
            if traceID := r.Header.Get("X-Trace-ID"); traceID != "" {
                traceContext.TraceID = traceID
                traceContext.SpanID = GenerateSpanID()
                traceContext.ParentSpanID = r.Header.Get("X-Span-ID")
                traceContext.Sampled = r.Header.Get("X-Sampled") == "1"
            } else {
                // 创建新的追踪上下文
                traceContext = TraceContext{
                    TraceID:  GenerateTraceID(),
                    SpanID:   GenerateSpanID(),
                    Sampled:  true, // 简化示例，实际应根据采样策略决定
                    Tags:     make(map[string]string),
                }
            }
            
            // 设置开始时间
            traceContext.StartTime = time.Now()
            
            // 添加标签
            traceContext.Tags = map[string]string{
                "service": serviceName,
                "http.method": r.Method,
                "http.url": r.URL.String(),
                "http.host": r.Host,
            }
            
            // 将追踪上下文放入请求上下文
            ctx := context.WithValue(r.Context(), "trace", traceContext)
            
            // 设置响应头
            w.Header().Set("X-Trace-ID", traceContext.TraceID)
            w.Header().Set("X-Span-ID", traceContext.SpanID)
            
            // 创建响应记录器
            recorder := &responseRecorder{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
            }
            
            // 处理请求
            next.ServeHTTP(recorder, r.WithContext(ctx))
            
            // 记录追踪信息
            duration := time.Since(traceContext.StartTime)
            logTraceSpan(traceContext, duration, recorder.statusCode)
        })
    }
}

// 记录追踪Span
func logTraceSpan(ctx TraceContext, duration time.Duration, statusCode int) {
    // 在实际应用中，应将追踪信息发送到追踪系统，如Jaeger或Zipkin
    // 这里简化为日志输出
    log.Printf("Trace: %s, Span: %s, Parent: %s, Duration: %v, Status: %d, Tags: %v",
        ctx.TraceID, ctx.SpanID, ctx.ParentSpanID, duration, statusCode, ctx.Tags)
}

// 创建子Span
func CreateChildSpan(ctx context.Context, name string) (context.Context, TraceContext) {
    parentCtx, ok := ctx.Value("trace").(TraceContext)
    if !ok {
        // 如果没有父追踪上下文，创建新的
        parentCtx = TraceContext{
            TraceID:  GenerateTraceID(),
            SpanID:   GenerateSpanID(),
            Sampled:  true,
            Tags:     make(map[string]string),
            StartTime: time.Now(),
        }
    }
    
    // 创建子Span
    childCtx := TraceContext{
        TraceID:      parentCtx.TraceID,
        SpanID:       GenerateSpanID(),
        ParentSpanID: parentCtx.SpanID,
        Sampled:      parentCtx.Sampled,
        Tags:         make(map[string]string),
        StartTime:    time.Now(),
    }
    
    // 复制父标签
    for k, v := range parentCtx.Tags {
        childCtx.Tags[k] = v
    }
    
    // 添加Span名称
    childCtx.Tags["name"] = name
    
    return context.WithValue(ctx, "trace", childCtx), childCtx
}

// 结束Span
func EndSpan(ctx TraceContext, err error) {
    duration := time.Since(ctx.StartTime)
    
    if err != nil {
        ctx.Tags["error"] = err.Error()
    }
    
    // 记录Span
    logTraceSpan(ctx, duration, 0)
}

// 使用示例
func ExampleTracingMiddleware() {
    // 创建追踪中间件
    tracingMiddleware := TracingMiddleware("example-service")
    
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从上下文获取追踪信息
        ctx := r.Context()
        
        // 创建子Span
        ctx, span := CreateChildSpan(ctx, "process-data")
        
        // 模拟处理
        time.Sleep(100 * time.Millisecond)
        
        // 结束Span
        EndSpan(span, nil)
        
        w.Write([]byte("Hello, World!"))
    })
    
    // 应用中间件
    http.Handle("/api/hello", tracingMiddleware(handler))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 日志聚合中间件
日志聚合中间件用于收集和整理应用程序的日志信息，便于后续分析和故障排查。

```go
// 日志级别
type LogLevel int

const (
    DebugLevel LogLevel = iota
    InfoLevel
    WarnLevel
    ErrorLevel
    FatalLevel
)

// 日志级别名称
var logLevelNames = map[LogLevel]string{
    DebugLevel: "DEBUG",
    InfoLevel:  "INFO",
    WarnLevel:  "WARN",
    ErrorLevel: "ERROR",
    FatalLevel: "FATAL",
}

// 日志条目
type LogEntry struct {
    Level     LogLevel
    Message   string
    Timestamp time.Time
    Fields    map[string]interface{}
}

// 日志处理器接口
type LogHandler interface {
    Handle(entry LogEntry)
}

// 日志记录器
type Logger struct {
    handlers []LogHandler
    fields   map[string]interface{}
}

// 创建日志记录器
func NewLogger() *Logger {
    return &Logger{
        handlers: make([]LogHandler, 0),
        fields:   make(map[string]interface{}),
    }
}

// 添加日志处理器
func (l *Logger) AddHandler(handler LogHandler) {
    l.handlers = append(l.handlers, handler)
}

// 添加字段
func (l *Logger) WithField(key string, value interface{}) *Logger {
    newLogger := &Logger{
        handlers: l.handlers,
        fields:   make(map[string]interface{}),
    }
    
    // 复制现有字段
    for k, v := range l.fields {
        newLogger.fields[k] = v
    }
    
    // 添加新字段
    newLogger.fields[key] = value
    
    return newLogger
}

// 添加多个字段
func (l *Logger) WithFields(fields map[string]interface{}) *Logger {
    newLogger := &Logger{
        handlers: l.handlers,
        fields:   make(map[string]interface{}),
    }
    
    // 复制现有字段
    for k, v := range l.fields {
        newLogger.fields[k] = v
    }
    
    // 添加新字段
    for k, v := range fields {
        newLogger.fields[k] = v
    }
    
    return newLogger
}

// 记录日志
func (l *Logger) log(level LogLevel, message string) {
    entry := LogEntry{
        Level:     level,
        Message:   message,
        Timestamp: time.Now(),
        Fields:    l.fields,
    }
    
    for _, handler := range l.handlers {
        handler.Handle(entry)
    }
}

// 调试日志
func (l *Logger) Debug(message string) {
    l.log(DebugLevel, message)
}

// 信息日志
func (l *Logger) Info(message string) {
    l.log(InfoLevel, message)
}

// 警告日志
func (l *Logger) Warn(message string) {
    l.log(WarnLevel, message)
}

// 错误日志
func (l *Logger) Error(message string) {
    l.log(ErrorLevel, message)
}

// 致命日志
func (l *Logger) Fatal(message string) {
    l.log(FatalLevel, message)
    os.Exit(1)
}

// 控制台日志处理器
type ConsoleLogHandler struct {
    MinLevel LogLevel
}

// 处理日志条目
func (h *ConsoleLogHandler) Handle(entry LogEntry) {
    if entry.Level < h.MinLevel {
        return
    }
    
    // 格式化日志
    levelName := logLevelNames[entry.Level]
    timestamp := entry.Timestamp.Format("2006-01-02 15:04:05.000")
    
    // 基本信息
    message := fmt.Sprintf("[%s] %s %-5s %s", timestamp, levelName, entry.Message)
    
    // 添加字段
    if len(entry.Fields) > 0 {
        fieldsStr := ""
        for k, v := range entry.Fields {
            fieldsStr += fmt.Sprintf(" %s=%v", k, v)
        }
        message += fieldsStr
    }
    
    // 输出到控制台
    fmt.Println(message)
}

// 文件日志处理器
type FileLogHandler struct {
    MinLevel LogLevel
    FilePath string
    file     *os.File
    mu       sync.Mutex
}

// 创建文件日志处理器
func NewFileLogHandler(filePath string, minLevel LogLevel) (*FileLogHandler, error) {
    file, err := os.OpenFile(filePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
    if err != nil {
        return nil, err
    }
    
    return &FileLogHandler{
        MinLevel: minLevel,
        FilePath: filePath,
        file:     file,
    }, nil
}

// 处理日志条目
func (h *FileLogHandler) Handle(entry LogEntry) {
    if entry.Level < h.MinLevel {
        return
    }
    
    h.mu.Lock()
    defer h.mu.Unlock()
    
    // 格式化日志
    levelName := logLevelNames[entry.Level]
    timestamp := entry.Timestamp.Format("2006-01-02 15:04:05.000")
    
    // 基本信息
    message := fmt.Sprintf("[%s] %s %-5s %s", timestamp, levelName, entry.Message)
    
    // 添加字段
    if len(entry.Fields) > 0 {
        fieldsJSON, _ := json.Marshal(entry.Fields)
        message += " " + string(fieldsJSON)
    }
    
    // 写入文件
    message += "\n"
    h.file.WriteString(message)
}

// 关闭文件
func (h *FileLogHandler) Close() error {
    h.mu.Lock()
    defer h.mu.Unlock()
    
    return h.file.Close()
}

// 日志中间件
func LoggingMiddleware(logger *Logger) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            startTime := time.Now()
            
            // 为请求创建日志记录器
            requestID := r.Header.Get("X-Request-ID")
            if requestID == "" {
                requestID = GenerateSpanID()
                r.Header.Set("X-Request-ID", requestID)
            }
            
            requestLogger := logger.WithFields(map[string]interface{}{
                "request_id": requestID,
                "method":     r.Method,
                "path":       r.URL.Path,
                "remote_addr": r.RemoteAddr,
                "user_agent": r.UserAgent(),
            })
            
            // 记录请求开始
            requestLogger.Info("开始处理请求")
            
            // 创建响应记录器
            recorder := &responseRecorder{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
                body:           &bytes.Buffer{},
            }
            
            // 将日志记录器放入上下文
            ctx := context.WithValue(r.Context(), "logger", requestLogger)
            
            // 处理请求
            next.ServeHTTP(recorder, r.WithContext(ctx))
            
            // 记录请求完成
            duration := time.Since(startTime)
            requestLogger.WithFields(map[string]interface{}{
                "status":      recorder.statusCode,
                "duration_ms": duration.Milliseconds(),
                "size":        recorder.body.Len(),
            }).Info("请求处理完成")
        })
    }
}

// 响应记录器（带有记录响应体的功能）
type responseRecorder struct {
    http.ResponseWriter
    statusCode int
    body       *bytes.Buffer
}

// 写入响应
func (r *responseRecorder) Write(b []byte) (int, error) {
    r.body.Write(b)
    return r.ResponseWriter.Write(b)
}

// 设置状态码
func (r *responseRecorder) WriteHeader(statusCode int) {
    r.statusCode = statusCode
    r.ResponseWriter.WriteHeader(statusCode)
}

// 获取上下文中的日志记录器
func GetLogger(ctx context.Context) *Logger {
    if logger, ok := ctx.Value("logger").(*Logger); ok {
        return logger
    }
    
    // 返回默认日志记录器
    return NewLogger()
}

// 使用示例
func ExampleLoggingMiddleware() {
    // 创建日志记录器
    logger := NewLogger()
    
    // 添加控制台处理器
    logger.AddHandler(&ConsoleLogHandler{
        MinLevel: InfoLevel,
    })
    
    // 添加文件处理器
    fileHandler, err := NewFileLogHandler("app.log", DebugLevel)
    if err != nil {
        log.Fatalf("创建文件日志处理器失败: %v", err)
    }
    defer fileHandler.Close()
    
    logger.AddHandler(fileHandler)
    
    // 创建日志中间件
    loggingMiddleware := LoggingMiddleware(logger)
    
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 获取上下文中的日志记录器
        logger := GetLogger(r.Context())
        
        // 记录日志
        logger.Debug("处理请求中...")
        
        // 模拟处理
        time.Sleep(100 * time.Millisecond)
        
        // 响应
        w.Write([]byte("Hello, World!"))
    })
    
    // 应用中间件
    http.Handle("/api/hello", loggingMiddleware(handler))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 性能分析中间件
性能分析中间件用于监控和分析应用程序的性能瓶颈，帮助开发者优化系统性能。

```go
// 性能分析记录
type ProfileRecord struct {
    Name      string
    StartTime time.Time
    EndTime   time.Time
    Duration  time.Duration
    Children  []*ProfileRecord
    parent    *ProfileRecord
}

// 创建新的性能分析记录
func NewProfileRecord(name string) *ProfileRecord {
    return &ProfileRecord{
        Name:      name,
        StartTime: time.Now(),
        Children:  make([]*ProfileRecord, 0),
    }
}

// 开始子记录
func (r *ProfileRecord) StartChild(name string) *ProfileRecord {
    child := NewProfileRecord(name)
    child.parent = r
    r.Children = append(r.Children, child)
    return child
}

// 结束记录
func (r *ProfileRecord) End() {
    r.EndTime = time.Now()
    r.Duration = r.EndTime.Sub(r.StartTime)
}

// 获取记录树
func (r *ProfileRecord) Tree() map[string]interface{} {
    result := map[string]interface{}{
        "name":     r.Name,
        "duration": r.Duration.String(),
    }
    
    if len(r.Children) > 0 {
        children := make([]map[string]interface{}, len(r.Children))
        for i, child := range r.Children {
            children[i] = child.Tree()
        }
        result["children"] = children
    }
    
    return result
}

// 性能分析上下文
type ProfilerContext struct {
    rootRecord *ProfileRecord
    current    *ProfileRecord
    enabled    bool
}

// 创建新的性能分析上下文
func NewProfilerContext(enabled bool) *ProfilerContext {
    root := NewProfileRecord("root")
    return &ProfilerContext{
        rootRecord: root,
        current:    root,
        enabled:    enabled,
    }
}

// 开始记录
func (pc *ProfilerContext) Start(name string) {
    if !pc.enabled {
        return
    }
    
    pc.current = pc.current.StartChild(name)
}

// 结束记录
func (pc *ProfilerContext) End() {
    if !pc.enabled {
        return
    }
    
    pc.current.End()
    if pc.current.parent != nil {
        pc.current = pc.current.parent
    }
}

// 获取记录树
func (pc *ProfilerContext) GetTree() map[string]interface{} {
    return pc.rootRecord.Tree()
}

// 性能分析中间件
func ProfilerMiddleware(enabled bool) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 创建性能分析上下文
            pc := NewProfilerContext(enabled)
            pc.Start("request")
            
            // 将上下文放入请求上下文
            ctx := context.WithValue(r.Context(), "profiler", pc)
            
            // 处理请求
            next.ServeHTTP(w, r.WithContext(ctx))
            
            // 结束记录
            pc.End()
            
            // 如果启用了性能分析，设置响应头
            if enabled {
                w.Header().Set("X-Profile", "enabled")
            }
        })
    }
}

// 获取上下文中的性能分析器
func GetProfiler(ctx context.Context) *ProfilerContext {
    if pc, ok := ctx.Value("profiler").(*ProfilerContext); ok {
        return pc
    }
    
    // 返回禁用的性能分析器
    return NewProfilerContext(false)
}

// 性能分析导出处理器
func ProfilerHandler() http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 获取上下文中的性能分析器
        pc := GetProfiler(r.Context())
        
        // 获取记录树
        tree := pc.GetTree()
        
        // 序列化为JSON
        data, err := json.MarshalIndent(tree, "", "  ")
        if err != nil {
            http.Error(w, "序列化性能分析数据失败", http.StatusInternalServerError)
            return
        }
        
        w.Header().Set("Content-Type", "application/json")
        w.Write(data)
    })
}

// 使用示例
func ExampleProfilerMiddleware() {
    // 创建性能分析中间件
    profilerMiddleware := ProfilerMiddleware(true)
    
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 获取上下文中的性能分析器
        pc := GetProfiler(r.Context())
        
        // 记录数据库操作
        pc.Start("database-query")
        time.Sleep(50 * time.Millisecond) // 模拟数据库查询
        pc.End()
        
        // 记录业务逻辑处理
        pc.Start("business-logic")
        time.Sleep(30 * time.Millisecond) // 模拟业务逻辑处理
        pc.End()
        
        // 记录模板渲染
        pc.Start("template-render")
        time.Sleep(20 * time.Millisecond) // 模拟模板渲染
        pc.End()
        
        w.Write([]byte("Hello, World!"))
    })
    
    // 应用中间件
    http.Handle("/api/hello", profilerMiddleware(handler))
    
    // 性能分析导出
    http.Handle("/debug/profile", profilerMiddleware(ProfilerHandler()))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### 21.10 限流和熔断中间件

#### 限流算法实现
限流算法用于控制系统的请求处理速率，防止系统过载。常见的限流算法包括令牌桶、漏桶等。

```go
// 令牌桶限流器
type TokenBucket struct {
    rate       float64    // 令牌生成速率（令牌/秒）
    capacity   float64    // 桶容量
    tokens     float64    // 当前令牌数
    lastRefill time.Time  // 上次填充时间
    mu         sync.Mutex
}

// 创建令牌桶限流器
func NewTokenBucket(rate, capacity float64) *TokenBucket {
    return &TokenBucket{
        rate:       rate,
        capacity:   capacity,
        tokens:     capacity,
        lastRefill: time.Now(),
    }
}

// 尝试获取令牌
func (tb *TokenBucket) TakeToken() bool {
    tb.mu.Lock()
    defer tb.mu.Unlock()
    
    // 计算自上次填充以来经过的时间
    now := time.Now()
    elapsed := now.Sub(tb.lastRefill).Seconds()
    
    // 计算新增的令牌数
    newTokens := elapsed * tb.rate
    
    // 更新当前令牌数，但不超过容量
    tb.tokens = math.Min(tb.capacity, tb.tokens + newTokens)
    tb.lastRefill = now
    
    // 尝试获取令牌
    if tb.tokens >= 1 {
        tb.tokens--
        return true
    }
    
    return false
}

// 漏桶限流器
type LeakyBucket struct {
    capacity    int64     // 桶容量
    remaining   int64     // 剩余容量
    leakRate    float64   // 漏出速率（请求/秒）
    lastLeakTime time.Time // 上次漏出时间
    mu          sync.Mutex
}

// 创建漏桶限流器
func NewLeakyBucket(capacity int64, leakRate float64) *LeakyBucket {
    return &LeakyBucket{
        capacity:    capacity,
        remaining:   capacity,
        leakRate:    leakRate,
        lastLeakTime: time.Now(),
    }
}

// 尝试添加请求
func (lb *LeakyBucket) TryAdd() bool {
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    // 计算自上次漏出以来经过的时间
    now := time.Now()
    elapsed := now.Sub(lb.lastLeakTime).Seconds()
    
    // 计算漏出的请求数
    leaked := int64(math.Floor(elapsed * lb.leakRate))
    
    // 更新剩余容量，但不超过桶容量
    if leaked > 0 {
        lb.remaining = int64(math.Min(float64(lb.capacity), float64(lb.remaining + leaked)))
        lb.lastLeakTime = now
    }
    
    // 尝试添加请求
    if lb.remaining > 0 {
        lb.remaining--
        return true
    }
    
    return false
}

// 滑动窗口限流器
type SlidingWindowLimiter struct {
    capacity    int            // 窗口容量
    timeWindow  time.Duration  // 时间窗口
    requests    []time.Time    // 请求时间列表
    mu          sync.Mutex
}

// 创建滑动窗口限流器
func NewSlidingWindowLimiter(capacity int, timeWindow time.Duration) *SlidingWindowLimiter {
    return &SlidingWindowLimiter{
        capacity:   capacity,
        timeWindow: timeWindow,
        requests:   make([]time.Time, 0, capacity),
    }
}

// 尝试添加请求
func (swl *SlidingWindowLimiter) TryAdd() bool {
    swl.mu.Lock()
    defer swl.mu.Unlock()
    
    now := time.Now()
    windowStart := now.Add(-swl.timeWindow)
    
    // 移除过期的请求
    i := 0
    for ; i < len(swl.requests); i++ {
        if swl.requests[i].After(windowStart) {
            break
        }
    }
    
    if i > 0 {
        swl.requests = swl.requests[i:]
    }
    
    // 检查是否超出容量
    if len(swl.requests) >= swl.capacity {
        return false
    }
    
    // 添加请求
    swl.requests = append(swl.requests, now)
    return true
}

// 限流中间件
func RateLimitMiddleware(limiter interface{}) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            var allowed bool
            
            // 根据限流器类型调用相应的方法
            switch l := limiter.(type) {
            case *TokenBucket:
                allowed = l.TakeToken()
            case *LeakyBucket:
                allowed = l.TryAdd()
            case *SlidingWindowLimiter:
                allowed = l.TryAdd()
            default:
                // 默认允许通过
                allowed = true
            }
            
            if !allowed {
                w.Header().Set("Retry-After", "1")
                http.Error(w, "请求过多，请稍后再试", http.StatusTooManyRequests)
                return
            }
            
            next.ServeHTTP(w, r)
        })
    }
}
```

#### 熔断器模式
熔断器模式用于防止系统级联失败，当检测到故障时自动断开故障服务，等待服务恢复后再重新连接。

```go
// 熔断器状态
type CircuitState int

const (
    CircuitClosed   CircuitState = iota // 关闭状态：正常工作
    CircuitOpen                         // 开启状态：快速失败
    CircuitHalfOpen                     // 半开启状态：允许部分请求通过
)

// 熔断器配置
type CircuitBreakerConfig struct {
    FailureThreshold   int           // 触发熔断的连续失败次数
    SuccessThreshold   int           // 恢复服务的连续成功次数
    Timeout            time.Duration // 熔断器开启后，多久进入半开启状态
    MaxConcurrent      int           // 最大并发请求数
}

// 熔断器
type CircuitBreaker struct {
    config         CircuitBreakerConfig
    state          CircuitState
    failures       int
    successes      int
    lastStateChange time.Time
    concurrent     int
    mu             sync.Mutex
}

// 创建熔断器
func NewCircuitBreaker(config CircuitBreakerConfig) *CircuitBreaker {
    return &CircuitBreaker{
        config:        config,
        state:         CircuitClosed,
        lastStateChange: time.Now(),
    }
}

// 执行函数并应用熔断逻辑
func (cb *CircuitBreaker) Execute(fn func() error) error {
    // 检查是否允许执行
    if err := cb.beforeExecute(); err != nil {
        return err
    }
    
    // 函数执行结束后减少并发计数
    defer cb.afterExecute()
    
    // 执行函数
    err := fn()
    
    // 处理执行结果
    cb.handleResult(err)
    
    return err
}

// 执行前检查
func (cb *CircuitBreaker) beforeExecute() error {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    now := time.Now()
    
    switch cb.state {
    case CircuitOpen:
        // 如果熔断器开启且超过超时时间，进入半开启状态
        if now.Sub(cb.lastStateChange) > cb.config.Timeout {
            cb.tripToHalfOpen(now)
        } else {
            return fmt.Errorf("熔断器开启")
        }
    case CircuitHalfOpen:
        // 半开启状态下限制并发请求
        if cb.concurrent >= 1 {
            return fmt.Errorf("熔断器半开启，已达到并发限制")
        }
    }
    
    // 检查最大并发请求数
    if cb.config.MaxConcurrent > 0 && cb.concurrent >= cb.config.MaxConcurrent {
        return fmt.Errorf("已达到最大并发请求数")
    }
    
    // 增加并发计数
    cb.concurrent++
    
    return nil
}

// 执行后处理
func (cb *CircuitBreaker) afterExecute() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    // 减少并发计数
    cb.concurrent--
}

// 处理执行结果
func (cb *CircuitBreaker) handleResult(err error) {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    now := time.Now()
    
    if err != nil {
        // 处理失败
        cb.failures++
        cb.successes = 0
        
        // 检查是否达到失败阈值
        if cb.state == CircuitClosed && cb.failures >= cb.config.FailureThreshold {
            cb.tripToOpen(now)
        } else if cb.state == CircuitHalfOpen {
            cb.tripToOpen(now)
        }
    } else {
        // 处理成功
        cb.successes++
        cb.failures = 0
        
        // 检查是否达到成功阈值
        if cb.state == CircuitHalfOpen && cb.successes >= cb.config.SuccessThreshold {
            cb.tripToClosed(now)
        }
    }
}

// 切换到开启状态
func (cb *CircuitBreaker) tripToOpen(now time.Time) {
    cb.state = CircuitOpen
    cb.lastStateChange = now
}

// 切换到半开启状态
func (cb *CircuitBreaker) tripToHalfOpen(now time.Time) {
    cb.state = CircuitHalfOpen
    cb.lastStateChange = now
    cb.failures = 0
    cb.successes = 0
}

// 切换到关闭状态
func (cb *CircuitBreaker) tripToClosed(now time.Time) {
    cb.state = CircuitClosed
    cb.lastStateChange = now
    cb.failures = 0
    cb.successes = 0
}

// 获取当前状态
func (cb *CircuitBreaker) State() CircuitState {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    return cb.state
}

// 熔断中间件
func CircuitBreakerMiddleware(cb *CircuitBreaker) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 创建响应记录器
            recorder := &responseRecorder{
                ResponseWriter: w,
                statusCode:     http.StatusOK,
            }
            
            // 执行请求处理
            err := cb.Execute(func() error {
                next.ServeHTTP(recorder, r)
                
                // 检查状态码是否表示错误
                if recorder.statusCode >= 500 {
                    return fmt.Errorf("服务器错误: %d", recorder.statusCode)
                }
                
                return nil
            })
            
            // 如果熔断器拒绝请求，返回服务不可用
            if err != nil && cb.State() != CircuitClosed {
                http.Error(w, "服务暂时不可用", http.StatusServiceUnavailable)
            }
        })
    }
}

// 使用示例
func ExampleCircuitBreakerMiddleware() {
    // 创建熔断器
    cb := NewCircuitBreaker(CircuitBreakerConfig{
        FailureThreshold: 5,
        SuccessThreshold: 2,
        Timeout:          5 * time.Second,
        MaxConcurrent:    100,
    })
    
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 模拟随机故障
        if rand.Float64() < 0.2 {
            w.WriteHeader(http.StatusInternalServerError)
            w.Write([]byte("服务器内部错误"))
            return
        }
        
        w.Write([]byte("Hello, World!"))
    })
    
    // 应用熔断中间件
    http.Handle("/api/hello", CircuitBreakerMiddleware(cb)(handler))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 降级策略中间件
降级策略中间件在系统负载过高或部分服务不可用时，提供有限功能或备用功能，保障系统核心功能的可用性。

```go
// 降级策略类型
type FallbackStrategy int

const (
    // 静态响应降级
    StaticFallback FallbackStrategy = iota
    // 缓存数据降级
    CacheFallback
    // 有限功能降级
    LimitedFallback
)

// 降级配置
type FallbackConfig struct {
    Strategy      FallbackStrategy
    StaticContent []byte
    CacheProvider func(r *http.Request) ([]byte, error)
    LimitedHandler http.Handler
}

// 降级中间件
type FallbackMiddleware struct {
    config    FallbackConfig
    condition func(r *http.Request) bool
}

// 创建降级中间件
func NewFallbackMiddleware(config FallbackConfig, condition func(r *http.Request) bool) *FallbackMiddleware {
    return &FallbackMiddleware{
        config:    config,
        condition: condition,
    }
}

// 处理函数
func (m *FallbackMiddleware) HandleFunc() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 检查是否满足降级条件
            if m.condition(r) {
                // 应用降级策略
                switch m.config.Strategy {
                case StaticFallback:
                    // 返回静态响应
                    w.WriteHeader(http.StatusOK)
                    w.Write(m.config.StaticContent)
                    
                case CacheFallback:
                    // 尝试从缓存获取数据
                    if m.config.CacheProvider != nil {
                        data, err := m.config.CacheProvider(r)
                        if err == nil {
                            w.WriteHeader(http.StatusOK)
                            w.Write(data)
                        } else {
                            http.Error(w, "服务暂时不可用", http.StatusServiceUnavailable)
                        }
                    } else {
                        http.Error(w, "服务暂时不可用", http.StatusServiceUnavailable)
                    }
                    
                case LimitedFallback:
                    // 使用有限功能处理器
                    if m.config.LimitedHandler != nil {
                        m.config.LimitedHandler.ServeHTTP(w, r)
                    } else {
                        http.Error(w, "服务暂时不可用", http.StatusServiceUnavailable)
                    }
                }
                
                return
            }
            
            // 正常处理请求
            next.ServeHTTP(w, r)
        })
    }
}

// 系统负载检查条件
func SystemLoadCondition(loadThreshold float64) func(r *http.Request) bool {
    return func(r *http.Request) bool {
        // 获取系统负载
        info, err := load.Avg()
        if err != nil {
            // 如果无法获取负载信息，假设不需要降级
            return false
        }
        
        // 检查1分钟负载是否超过阈值
        return info.Load1 > loadThreshold
    }
}

// 基于熔断器状态的条件
func CircuitBreakerCondition(cb *CircuitBreaker) func(r *http.Request) bool {
    return func(r *http.Request) bool {
        // 如果熔断器开启，触发降级
        return cb.State() == CircuitOpen
    }
}

// 使用示例
func ExampleFallbackMiddleware() {
    // 创建熔断器
    cb := NewCircuitBreaker(CircuitBreakerConfig{
        FailureThreshold: 5,
        SuccessThreshold: 2,
        Timeout:          5 * time.Second,
    })
    
    // 创建静态降级内容
    staticContent := []byte(`{"status": "limited", "message": "系统正在维护中，请稍后再试"}`)
    
    // 创建降级中间件
    fallbackMiddleware := NewFallbackMiddleware(
        FallbackConfig{
            Strategy:      StaticFallback,
            StaticContent: staticContent,
        },
        CircuitBreakerCondition(cb),
    )
    
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 正常处理逻辑
        w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"status": "ok", "data": {"message": "Hello, World!"}}`))
    })
    
    // 应用中间件
    http.Handle("/api/hello",
        CircuitBreakerMiddleware(cb)(
            fallbackMiddleware.HandleFunc()(handler),
        ),
    )
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

#### 流量控制中间件
流量控制中间件用于管理和调度系统的请求流量，确保系统稳定运行，防止过载。

```go
// 流量控制策略
type TrafficControlStrategy int

const (
    // 随机丢弃
    RandomDrop TrafficControlStrategy = iota
    // 根据优先级丢弃
    PriorityDrop
    // 请求排队
    RequestQueue
)

// 流量控制配置
type TrafficControlConfig struct {
    Strategy        TrafficControlStrategy
    MaxRequests     int
    DropRate        float64
    PriorityFunc    func(r *http.Request) int
    QueueTimeout    time.Duration
}

// 流量控制中间件
type TrafficControlMiddleware struct {
    config          TrafficControlConfig
    currentRequests *atomic.Int64
    requestQueue    chan requestTask
}

// 请求任务
type requestTask struct {
    w          http.ResponseWriter
    r          *http.Request
    handler    http.Handler
    done       chan struct{}
}

// 创建流量控制中间件
func NewTrafficControlMiddleware(config TrafficControlConfig) *TrafficControlMiddleware {
    middleware := &TrafficControlMiddleware{
        config:          config,
        currentRequests: &atomic.Int64{},
    }
    
    if config.Strategy == RequestQueue {
        middleware.requestQueue = make(chan requestTask, config.MaxRequests)
        
        // 启动处理协程
        for i := 0; i < config.MaxRequests; i++ {
            go middleware.processQueue()
        }
    }
    
    return middleware
}

// 处理队列中的请求
func (m *TrafficControlMiddleware) processQueue() {
    for task := range m.requestQueue {
        m.currentRequests.Add(1)
        task.handler.ServeHTTP(task.w, task.r)
        m.currentRequests.Add(-1)
        close(task.done)
    }
}

// 处理函数
func (m *TrafficControlMiddleware) HandleFunc() func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            current := m.currentRequests.Load()
            
            // 检查当前请求数是否超过限制
            if current >= int64(m.config.MaxRequests) {
                switch m.config.Strategy {
                case RandomDrop:
                    // 随机丢弃请求
                    if rand.Float64() < m.config.DropRate {
                        http.Error(w, "服务繁忙，请稍后再试", http.StatusServiceUnavailable)
                        return
                    }
                    
                case PriorityDrop:
                    // 根据优先级丢弃请求
                    if m.config.PriorityFunc != nil {
                        priority := m.config.PriorityFunc(r)
                        if priority < int(float64(m.config.MaxRequests)*m.config.DropRate) {
                            http.Error(w, "服务繁忙，请稍后再试", http.StatusServiceUnavailable)
                            return
                        }
                    }
                    
                case RequestQueue:
                    // 将请求放入队列
                    task := requestTask{
                        w:       w,
                        r:       r,
                        handler: next,
                        done:    make(chan struct{}),
                    }
                    
                    // 尝试放入队列，设置超时
                    timeout := m.config.QueueTimeout
                    if timeout <= 0 {
                        timeout = 5 * time.Second
                    }
                    
                    select {
                    case m.requestQueue <- task:
                        // 等待请求处理完成或超时
                        select {
                        case <-task.done:
                            // 请求已处理
                        case <-time.After(timeout):
                            // 超时，返回错误
                            http.Error(w, "请求处理超时", http.StatusServiceUnavailable)
                        }
                    default:
                        // 队列已满，拒绝请求
                        http.Error(w, "服务繁忙，请稍后再试", http.StatusServiceUnavailable)
                    }
                    
                    return
                }
            }
            
            // 增加当前请求计数
            m.currentRequests.Add(1)
            defer m.currentRequests.Add(-1)
            
            // 处理请求
            next.ServeHTTP(w, r)
        })
    }
}

// 使用示例
func ExampleTrafficControlMiddleware() {
    // 创建流量控制中间件
    tcMiddleware := NewTrafficControlMiddleware(TrafficControlConfig{
        Strategy:     RequestQueue,
        MaxRequests:  1000,
        QueueTimeout: 10 * time.Second,
    })
    
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 模拟耗时操作
        time.Sleep(100 * time.Millisecond)
        
        w.Write([]byte("Hello, World!"))
    })
    
    // 应用中间件
    http.Handle("/api/hello", tcMiddleware.HandleFunc()(handler))
    
    // 启动服务器
    log.Fatal(http.ListenAndServe(":8080", nil))
}
```

### 21.11 配置管理中间件

#### 配置加载中间件
配置加载中间件负责从不同来源（如文件、环境变量、远程配置中心等）加载应用程序配置。

```go
// 配置来源接口
type ConfigSource interface {
    // 加载配置
    Load() (map[string]interface{}, error)
    // 来源名称
    Name() string
}

// 文件配置来源
type FileConfigSource struct {
    filePath string
}

// 创建文件配置来源
func NewFileConfigSource(filePath string) *FileConfigSource {
    return &FileConfigSource{
        filePath: filePath,
    }
}

// 加载配置
func (s *FileConfigSource) Load() (map[string]interface{}, error) {
    // 读取文件内容
    data, err := ioutil.ReadFile(s.filePath)
    if err != nil {
        return nil, fmt.Errorf("读取配置文件失败: %w", err)
    }
    
    // 根据文件扩展名解析配置
    var config map[string]interface{}
    
    switch filepath.Ext(s.filePath) {
    case ".json":
        if err := json.Unmarshal(data, &config); err != nil {
            return nil, fmt.Errorf("解析JSON配置失败: %w", err)
        }
    case ".yaml", ".yml":
        if err := yaml.Unmarshal(data, &config); err != nil {
            return nil, fmt.Errorf("解析YAML配置失败: %w", err)
        }
    default:
        return nil, fmt.Errorf("不支持的配置文件格式: %s", filepath.Ext(s.filePath))
    }
    
    return config, nil
}

// 来源名称
func (s *FileConfigSource) Name() string {
    return fmt.Sprintf("file:%s", s.filePath)
}

// 环境变量配置来源
type EnvConfigSource struct {
    prefix string
}

// 创建环境变量配置来源
func NewEnvConfigSource(prefix string) *EnvConfigSource {
    return &EnvConfigSource{
        prefix: prefix,
    }
}

// 加载配置
func (s *EnvConfigSource) Load() (map[string]interface{}, error) {
    config := make(map[string]interface{})
    
    // 获取所有环境变量
    for _, env := range os.Environ() {
        parts := strings.SplitN(env, "=", 2)
        if len(parts) != 2 {
            continue
        }
        
        key, value := parts[0], parts[1]
        
        // 检查前缀
        if s.prefix != "" && !strings.HasPrefix(key, s.prefix) {
            continue
        }
        
        // 移除前缀
        if s.prefix != "" {
            key = strings.TrimPrefix(key, s.prefix)
        }
        
        // 转换为嵌套结构
        s.setNestedValue(config, strings.Split(key, "_"), value)
    }
    
    return config, nil
}

// 设置嵌套值
func (s *EnvConfigSource) setNestedValue(config map[string]interface{}, path []string, value string) {
    if len(path) == 0 {
        return
    }
    
    key := strings.ToLower(path[0])
    
    if len(path) == 1 {
        // 尝试将字符串转换为适当的类型
        config[key] = s.parseValue(value)
        return
    }
    
    // 创建或获取嵌套映射
    nested, ok := config[key].(map[string]interface{})
    if !ok {
        nested = make(map[string]interface{})
        config[key] = nested
    }
    
    // 递归设置嵌套值
    s.setNestedValue(nested, path[1:], value)
}

// 解析值
func (s *EnvConfigSource) parseValue(value string) interface{} {
    // 尝试解析为布尔值
    if value == "true" {
        return true
    }
    if value == "false" {
        return false
    }
    
    // 尝试解析为整数
    if i, err := strconv.ParseInt(value, 10, 64); err == nil {
        return i
    }
    
    // 尝试解析为浮点数
    if f, err := strconv.ParseFloat(value, 64); err == nil {
        return f
    }
    
    // 返回原始字符串
    return value
}

// 来源名称
func (s *EnvConfigSource) Name() string {
    if s.prefix == "" {
        return "env"
    }
    return fmt.Sprintf("env:%s", s.prefix)
}

// 配置管理器
type ConfigManager struct {
    sources  []ConfigSource
    config   map[string]interface{}
    mu       sync.RWMutex
    watchers []func(map[string]interface{})
}

// 创建配置管理器
func NewConfigManager(sources ...ConfigSource) *ConfigManager {
    return &ConfigManager{
        sources:  sources,
        config:   make(map[string]interface{}),
        watchers: make([]func(map[string]interface{}), 0),
    }
}

// 加载配置
func (m *ConfigManager) Load() error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    // 创建新配置
    newConfig := make(map[string]interface{})
    
    // 从所有来源加载配置
    for _, source := range m.sources {
        config, err := source.Load()
        if err != nil {
            return fmt.Errorf("从来源加载配置失败 [%s]: %w", source.Name(), err)
        }
        
        // 合并配置
        m.mergeConfig(newConfig, config)
    }
    
    // 更新配置
    oldConfig := m.config
    m.config = newConfig
    
    // 通知观察者
    if !reflect.DeepEqual(oldConfig, newConfig) {
        for _, watcher := range m.watchers {
            go watcher(newConfig)
        }
    }
    
    return nil
}

// 合并配置
func (m *ConfigManager) mergeConfig(dst, src map[string]interface{}) {
    for key, srcVal := range src {
        dstVal, exists := dst[key]
        
        if !exists {
            // 键不存在，直接复制
            dst[key] = srcVal
            continue
        }
        
        // 如果两个值都是映射，递归合并
        srcMap, srcIsMap := srcVal.(map[string]interface{})
        dstMap, dstIsMap := dstVal.(map[string]interface{})
        
        if srcIsMap && dstIsMap {
            m.mergeConfig(dstMap, srcMap)
        } else {
            // 否则，源值覆盖目标值
            dst[key] = srcVal
        }
    }
}

// 获取值
func (m *ConfigManager) Get(path string) interface{} {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    parts := strings.Split(path, ".")
    return m.getNestedValue(m.config, parts)
}

// 获取嵌套值
func (m *ConfigManager) getNestedValue(config map[string]interface{}, path []string) interface{} {
    if len(path) == 0 {
        return nil
    }
    
    key := path[0]
    value, ok := config[key]
    if !ok {
        return nil
    }
    
    if len(path) == 1 {
        return value
    }
    
    // 递归获取嵌套值
    if nested, ok := value.(map[string]interface{}); ok {
        return m.getNestedValue(nested, path[1:])
    }
    
    return nil
}

// 获取字符串
func (m *ConfigManager) GetString(path string, defaultValue string) string {
    value := m.Get(path)
    if value == nil {
        return defaultValue
    }
    
    str, ok := value.(string)
    if !ok {
        return defaultValue
    }
    
    return str
}

// 获取整数
func (m *ConfigManager) GetInt(path string, defaultValue int) int {
    value := m.Get(path)
    if value == nil {
        return defaultValue
    }
    
    switch v := value.(type) {
    case int:
        return v
    case int64:
        return int(v)
    case float64:
        return int(v)
    case string:
        if i, err := strconv.Atoi(v); err == nil {
            return i
        }
    }
    
    return defaultValue
}

// 获取布尔值
func (m *ConfigManager) GetBool(path string, defaultValue bool) bool {
    value := m.Get(path)
    if value == nil {
        return defaultValue
    }
    
    switch v := value.(type) {
    case bool:
        return v
    case string:
        if b, err := strconv.ParseBool(v); err == nil {
            return b
        }
    }
    
    return defaultValue
}

// 添加观察者
func (m *ConfigManager) AddWatcher(watcher func(map[string]interface{})) {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    m.watchers = append(m.watchers, watcher)
}

// 配置中间件
func ConfigMiddleware(manager *ConfigManager) func(http.Handler) http.Handler {
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 将配置管理器放入请求上下文
            ctx := context.WithValue(r.Context(), "config", manager)
            
            // 处理请求
            next.ServeHTTP(w, r.WithContext(ctx))
        })
    }
}

// 获取配置管理器
func GetConfigManager(ctx context.Context) *ConfigManager {
    if cm, ok := ctx.Value("config").(*ConfigManager); ok {
        return cm
    }
    return nil
}
```

#### 动态配置更新
动态配置更新机制允许在不重启应用程序的情况下更新配置，提高系统的灵活性和可用性。

```go
// 配置更新器
type ConfigUpdater struct {
    manager     *ConfigManager
    sources     []ConfigSource
    interval    time.Duration
    stopChan    chan struct{}
    isRunning   bool
    mu          sync.Mutex
}

// 创建配置更新器
func NewConfigUpdater(manager *ConfigManager, interval time.Duration) *ConfigUpdater {
    return &ConfigUpdater{
        manager:  manager,
        sources:  manager.sources,
        interval: interval,
        stopChan: make(chan struct{}),
    }
}

// 启动更新器
func (u *ConfigUpdater) Start() {
    u.mu.Lock()
    defer u.mu.Unlock()
    
    if u.isRunning {
        return
    }
    
    u.isRunning = true
    go u.run()
}

// 停止更新器
func (u *ConfigUpdater) Stop() {
    u.mu.Lock()
    defer u.mu.Unlock()
    
    if !u.isRunning {
        return
    }
    
    u.isRunning = false
    close(u.stopChan)
}

// 运行更新循环
func (u *ConfigUpdater) run() {
    ticker := time.NewTicker(u.interval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            if err := u.manager.Load(); err != nil {
                log.Printf("更新配置失败: %v", err)
            }
        case <-u.stopChan:
            return
        }
    }
}

// 手动触发更新
func (u *ConfigUpdater) TriggerUpdate() error {
    return u.manager.Load()
}
```

#### 配置验证中间件
配置验证中间件用于检查配置的有效性，确保应用程序启动前配置符合预期。

```go
// 配置验证规则
type ConfigValidator interface {
    // 验证配置
    Validate(config map[string]interface{}) error
    // 规则名称
    Name() string
}

// 必需字段验证器
type RequiredFieldValidator struct {
    fields []string
}

// 创建必需字段验证器
func NewRequiredFieldValidator(fields ...string) *RequiredFieldValidator {
    return &RequiredFieldValidator{
        fields: fields,
    }
}

// 验证配置
func (v *RequiredFieldValidator) Validate(config map[string]interface{}) error {
    for _, field := range v.fields {
        parts := strings.Split(field, ".")
        value := getNestedValue(config, parts)
        
        if value == nil {
            return fmt.Errorf("缺少必需字段: %s", field)
        }
    }
    
    return nil
}

// 规则名称
func (v *RequiredFieldValidator) Name() string {
    return "required-fields"
}

// 获取嵌套值
func getNestedValue(config map[string]interface{}, path []string) interface{} {
    if len(path) == 0 {
        return nil
    }
    
    key := path[0]
    value, ok := config[key]
    if !ok {
        return nil
    }
    
    if len(path) == 1 {
        return value
    }
    
    // 递归获取嵌套值
    if nested, ok := value.(map[string]interface{}); ok {
        return getNestedValue(nested, path[1:])
    }
    
    return nil
}

// 类型验证器
type TypeValidator struct {
    fieldTypes map[string]string
}

// 创建类型验证器
func NewTypeValidator() *TypeValidator {
    return &TypeValidator{
        fieldTypes: make(map[string]string),
    }
}

// 添加字段类型
func (v *TypeValidator) AddFieldType(field, typeName string) {
    v.fieldTypes[field] = typeName
}

// 验证配置
func (v *TypeValidator) Validate(config map[string]interface{}) error {
    for field, typeName := range v.fieldTypes {
        parts := strings.Split(field, ".")
        value := getNestedValue(config, parts)
        
        if value == nil {
            continue // 字段不存在，跳过验证
        }
        
        // 验证类型
        switch typeName {
        case "string":
            if _, ok := value.(string); !ok {
                return fmt.Errorf("字段 %s 必须是字符串类型", field)
            }
        case "int":
            if _, ok := value.(int); !ok && !isInt(value) {
                return fmt.Errorf("字段 %s 必须是整数类型", field)
            }
        case "float":
            if _, ok := value.(float64); !ok && !isFloat(value) {
                return fmt.Errorf("字段 %s 必须是浮点数类型", field)
            }
        case "bool":
            if _, ok := value.(bool); !ok {
                return fmt.Errorf("字段 %s 必须是布尔类型", field)
            }
        case "array":
            if _, ok := value.([]interface{}); !ok {
                return fmt.Errorf("字段 %s 必须是数组类型", field)
            }
        case "object":
            if _, ok := value.(map[string]interface{}); !ok {
                return fmt.Errorf("字段 %s 必须是对象类型", field)
            }
        }
    }
    
    return nil
}

// 检查是否是整数
func isInt(value interface{}) bool {
    switch v := value.(type) {
    case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:
        return true
    case float64:
        return v == float64(int(v))
    }
    return false
}

// 检查是否是浮点数
func isFloat(value interface{}) bool {
    switch value.(type) {
    case float32, float64:
        return true
    }
    return false
}

// 规则名称
func (v *TypeValidator) Name() string {
    return "type-validator"
}

// 配置验证器
type ConfigValidationMiddleware struct {
    validators []ConfigValidator
}

// 创建配置验证中间件
func NewConfigValidationMiddleware() *ConfigValidationMiddleware {
    return &ConfigValidationMiddleware{
        validators: make([]ConfigValidator, 0),
    }
}

// 添加验证器
- 配置加载中间件
- 动态配置更新
- 配置验证中间件
- 多环境配置管理

### 21.12 中间件最佳实践

#### 中间件设计原则
设计高质量的中间件需要遵循一些关键原则，以确保其可用性、可维护性和性能。

```go
// 1. 单一职责原则
// 每个中间件应只负责一个功能，这样更容易测试和维护
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 只负责日志记录
        start := time.Now()
        
        // 调用下一个处理器
        next.ServeHTTP(w, r)
        
        // 记录请求信息
        log.Printf(
            "%s %s %s %v",
            r.Method,
            r.URL.Path,
            r.RemoteAddr,
            time.Since(start),
        )
    })
}

// 2. 可组合性原则
// 中间件应该是可组合的，可以与其他中间件一起工作
type Middleware func(http.Handler) http.Handler

// 组合多个中间件
func Chain(middlewares ...Middleware) Middleware {
    return func(next http.Handler) http.Handler {
        for i := len(middlewares) - 1; i >= 0; i-- {
            next = middlewares[i](next)
        }
        return next
    }
}

// 3. 上下文传递原则
// 使用上下文传递数据，而不是全局变量
func ContextMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 添加数据到上下文
        ctx := context.WithValue(r.Context(), "requestID", uuid.New().String())
        
        // 使用新的上下文
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

// 4. 错误处理原则
// 妥善处理错误，不要让中间件中的错误影响整个应用
func ErrorHandlingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                // 记录错误
                log.Printf("恢复自panic: %v", err)
                
                // 返回500错误
                http.Error(w, "内部服务器错误", http.StatusInternalServerError)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}

// 5. 配置灵活性原则
// 中间件应该可配置，以适应不同的使用场景
type RateLimiterOptions struct {
    Rate      float64
    Burst     int
    IPSpecific bool
}

func NewRateLimiterMiddleware(opts RateLimiterOptions) Middleware {
    // 根据选项创建限流器
    // ...
    
    return func(next http.Handler) http.Handler {
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            // 使用配置的限流器
            // ...
            
            next.ServeHTTP(w, r)
        })
    }
}

// 6. 文档完备原则
// 编写清晰的文档，包括中间件的用途、配置选项和示例

// AuthMiddleware provides JWT-based authentication for HTTP handlers.
//
// It verifies the JWT token from the Authorization header and sets the
// authenticated user in the request context.
//
// Options:
//   - Secret: The secret key used to sign the JWT tokens
//   - TokenLookup: Where to extract the token from (default: "header:Authorization")
//   - AuthScheme: Auth scheme to use (default: "Bearer")
//
// Example:
//
//   authMiddleware := auth.NewAuthMiddleware(auth.Options{
//       Secret: "your-secret-key",
//   })
//
//   http.Handle("/api/protected", authMiddleware(protectedHandler))
func AuthMiddleware(opts Options) Middleware {
    // ...
}
```

#### 性能优化策略
中间件性能优化对于高吞吐量的应用至关重要，以下是一些常用的优化策略。

```go
// 1. 避免过多的内存分配
// 使用对象池重用对象
var bufferPool = sync.Pool{
    New: func() interface{} {
        return bytes.NewBuffer(make([]byte, 4096))
    },
}

func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 从对象池获取缓冲区
        buf := bufferPool.Get().(*bytes.Buffer)
        buf.Reset()
        defer bufferPool.Put(buf)
        
        // 使用缓冲区记录日志
        fmt.Fprintf(buf, "%s %s", r.Method, r.URL.Path)
        
        next.ServeHTTP(w, r)
        
        // 写入日志
        log.Print(buf.String())
    })
}

// 2. 减少上下文切换
// 避免在中间件中使用阻塞操作
func NonBlockingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 在处理请求前执行的非阻塞操作
        
- 中间件设计原则
- 性能优化策略
- 错误处理和恢复
- 测试和调试技巧

## 面试要点
- 中间件的设计模式和原理
- HTTP中间件的实现机制
- gRPC拦截器的工作原理
- 中间件的性能考虑
- 中间件的可复用性设计
- 中间件的测试策略

## 实践练习
1. 开发完整的HTTP中间件框架
2. 实现分布式限流中间件
3. 构建数据库访问中间件
4. 创建监控和追踪中间件
5. 设计消息处理中间件 