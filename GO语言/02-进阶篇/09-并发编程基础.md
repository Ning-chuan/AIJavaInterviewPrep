# 第9章：并发编程基础（Goroutine与Channel）

## 章节概要
本章深入讲解GO语言的核心特性——并发编程，包括Goroutine的创建和管理、Channel的使用以及并发安全的基本概念。GO语言的并发模型基于CSP（Communicating Sequential Processes）理论，通过"不要通过共享内存来通信，而要通过通信来共享内存"的设计哲学，提供了简洁而强大的并发编程能力。

## 学习目标
- 深入理解Goroutine的工作原理、调度机制和生命周期
- 全面掌握Channel的各种使用方式和底层实现原理
- 熟练使用select语句处理多路通信和非阻塞操作
- 掌握Context包在并发控制中的应用
- 了解并发编程的常见模式、最佳实践和常见陷阱
- 具备解决复杂并发问题的能力，满足大厂面试要求

## 前置知识
- 理解进程、线程和协程的概念
- 熟悉GO语言基本语法和函数
- 了解同步和异步编程的区别

## 主要内容

### 9.1 Goroutine深度解析

#### 9.1.1 Goroutine概念与原理

**什么是Goroutine？**
Goroutine是GO语言实现的轻量级线程，由GO运行时管理。它是GO并发编程的基础，相比传统线程有以下优势：

```go
package main

import (
    "fmt"
    "runtime"
    "time"
)

// 基本Goroutine示例
func main() {
    fmt.Printf("主Goroutine开始，当前GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    
    // 普通函数调用（同步）
    sayHello("World")
    
    // 启动Goroutine（异步）
    go sayHello("Goroutine")
    
    // 启动多个Goroutine
    for i := 0; i < 3; i++ {
        go func(id int) {
            fmt.Printf("Goroutine %d 正在执行\n", id)
        }(i)
    }
    
    // 主Goroutine等待（简单方式，实际开发中不推荐）
    time.Sleep(time.Second)
    fmt.Printf("当前Goroutine数量: %d\n", runtime.NumGoroutine())
}

func sayHello(name string) {
    fmt.Printf("Hello, %s! 来自Goroutine ID: %d\n", name, getGoroutineID())
}

// 获取Goroutine ID（仅用于演示，生产环境不推荐）
func getGoroutineID() int {
    return runtime.NumGoroutine()
}
```

#### 9.1.2 Goroutine核心特性详解

**1. 轻量级特性**
```go
func demonstrateLightweight() {
    const numGoroutines = 100000
    
    // 记录内存使用
    var m1, m2 runtime.MemStats
    runtime.GC()
    runtime.ReadMemStats(&m1)
    
    done := make(chan bool)
    
    // 创建大量Goroutine
    for i := 0; i < numGoroutines; i++ {
        go func() {
            time.Sleep(time.Hour) // 模拟长时间运行
            done <- true
        }()
    }
    
    runtime.GC()
    runtime.ReadMemStats(&m2)
    
    fmt.Printf("创建 %d 个Goroutine\n", numGoroutines)
    fmt.Printf("内存增长: %d KB\n", (m2.Sys-m1.Sys)/1024)
    fmt.Printf("平均每个Goroutine内存: %d bytes\n", (m2.Sys-m1.Sys)/numGoroutines)
}
```

**2. 动态栈管理**
```go
func demonstrateStackGrowth() {
    go func() {
        // 递归函数会导致栈增长
        var recursiveFunc func(int)
        recursiveFunc = func(depth int) {
            if depth > 1000 {
                return
            }
            // 创建局部变量占用栈空间
            var buffer [1024]byte
            _ = buffer
            fmt.Printf("递归深度: %d\n", depth)
            recursiveFunc(depth + 1)
        }
        recursiveFunc(0)
    }()
    
    time.Sleep(time.Second)
}
```

**3. M:N调度模型深入理解**
```go
func demonstrateScheduling() {
    // 设置使用的CPU核心数
    runtime.GOMAXPROCS(2)
    
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
    
    // CPU密集型任务
    for i := 0; i < 4; i++ {
        go func(id int) {
            for j := 0; j < 1000000000; j++ {
                if j%100000000 == 0 {
                    fmt.Printf("Goroutine %d: %d\n", id, j)
                    runtime.Gosched() // 主动让出CPU
                }
            }
        }(i)
    }
    
    time.Sleep(5 * time.Second)
}
```

#### 9.1.3 Goroutine调度器（GMP模型）

**调度器组件：**
- **G (Goroutine)**：待执行的任务
- **M (Machine)**：操作系统线程
- **P (Processor)**：逻辑处理器，维护Goroutine队列

```go
func scheduleAnalysis() {
    // 查看调度器状态
    fmt.Printf("调度器信息:\n")
    fmt.Printf("GOMAXPROCS: %d\n", runtime.GOMAXPROCS(0))
    fmt.Printf("NumCPU: %d\n", runtime.NumCPU())
    fmt.Printf("NumGoroutine: %d\n", runtime.NumGoroutine())
    
    // 创建不同类型的Goroutine
    
    // 1. CPU密集型
    go func() {
        for i := 0; i < 1000000; i++ {
            _ = i * i
        }
    }()
    
    // 2. I/O密集型
    go func() {
        time.Sleep(time.Millisecond * 100)
    }()
    
    // 3. 阻塞型
    go func() {
        ch := make(chan int)
        <-ch // 永远阻塞
    }()
    
    time.Sleep(time.Second)
    fmt.Printf("执行后NumGoroutine: %d\n", runtime.NumGoroutine())
}

#### 9.1.4 Goroutine生命周期管理

**Goroutine状态转换：**
1. **创建** → **就绪** → **运行** → **阻塞** → **死亡**

```go
import "sync"

// 基本生命周期管理
func goroutineLifecycle() {
    var wg sync.WaitGroup
    
    fmt.Println("=== Goroutine生命周期演示 ===")
    
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            fmt.Printf("Goroutine %d: 创建并开始执行\n", id)
            
            // 模拟不同的工作负载
            switch id % 3 {
            case 0:
                // CPU密集型任务
                for j := 0; j < 1000000; j++ {
                    _ = j * j
                }
                fmt.Printf("Goroutine %d: CPU密集型任务完成\n", id)
            case 1:
                // I/O密集型任务
                time.Sleep(time.Millisecond * 100)
                fmt.Printf("Goroutine %d: I/O任务完成\n", id)
            case 2:
                // 混合任务
                time.Sleep(time.Millisecond * 50)
                for j := 0; j < 500000; j++ {
                    _ = j * j
                }
                fmt.Printf("Goroutine %d: 混合任务完成\n", id)
            }
            
            fmt.Printf("Goroutine %d: 即将结束\n", id)
        }(i)
    }
    
    fmt.Println("主Goroutine: 等待所有子Goroutine完成...")
    wg.Wait()
    fmt.Println("主Goroutine: 所有Goroutine执行完成")
}

// 高级生命周期管理：带超时和取消
func advancedLifecycleManagement() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()
    
    var wg sync.WaitGroup
    
    for i := 0; i < 3; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            select {
            case <-ctx.Done():
                fmt.Printf("Goroutine %d: 收到取消信号: %v\n", id, ctx.Err())
                return
            default:
                fmt.Printf("Goroutine %d: 开始长时间任务\n", id)
            }
            
            // 模拟长时间运行的任务
            for j := 0; j < 100; j++ {
                select {
                case <-ctx.Done():
                    fmt.Printf("Goroutine %d: 任务被中断: %v\n", id, ctx.Err())
                    return
                default:
                    time.Sleep(time.Millisecond * 50)
                    if j%20 == 0 {
                        fmt.Printf("Goroutine %d: 进度 %d%%\n", id, j)
                    }
                }
            }
            
            fmt.Printf("Goroutine %d: 任务正常完成\n", id)
        }(i)
    }
    
    wg.Wait()
}

// Goroutine池管理
type GoroutinePool struct {
    workers int
    jobs    chan func()
    quit    chan bool
}

func NewGoroutinePool(workers int) *GoroutinePool {
    pool := &GoroutinePool{
        workers: workers,
        jobs:    make(chan func(), workers*2),
        quit:    make(chan bool),
    }
    
    // 启动工作Goroutine
    for i := 0; i < workers; i++ {
        go func(workerID int) {
            for {
                select {
                case job := <-pool.jobs:
                    fmt.Printf("Worker %d: 执行任务\n", workerID)
                    job()
                case <-pool.quit:
                    fmt.Printf("Worker %d: 收到退出信号\n", workerID)
                    return
                }
            }
        }(i)
    }
    
    return pool
}

func (p *GoroutinePool) Submit(job func()) {
    p.jobs <- job
}

func (p *GoroutinePool) Stop() {
    close(p.quit)
}
```

### 9.2 Channel深度解析

#### 9.2.1 Channel概念与底层原理

**Channel是什么？**
Channel是GO语言中用于Goroutine间通信的管道，基于CSP（Communicating Sequential Processes）模型设计。它不仅用于数据传递，还用于同步控制。

**Channel底层结构（简化版）：**
```go
type hchan struct {
    qcount   uint           // 队列中的数据个数
    dataqsiz uint           // 环形队列的大小
    buf      unsafe.Pointer // 指向环形队列
    elemsize uint16         // 元素大小
    closed   uint32         // 是否关闭
    sendx    uint           // 发送索引
    recvx    uint           // 接收索引
    recvq    waitq          // 接收等待队列
    sendq    waitq          // 发送等待队列
    lock     mutex          // 互斥锁
}
```

#### 9.2.2 Channel创建和基本操作详解

```go
package main

import (
    "fmt"
    "time"
    "unsafe"
)

func channelBasics() {
    fmt.Println("=== Channel基础操作演示 ===")
    
    // 1. 创建不同类型的Channel
    unbufferedCh := make(chan int)           // 无缓冲Channel
    bufferedCh := make(chan int, 5)          // 有缓冲Channel
    stringCh := make(chan string, 2)         // 字符串Channel
    structCh := make(chan struct{}, 1)       // 空结构体Channel（信号量）
    
    fmt.Printf("无缓冲Channel大小: %d\n", cap(unbufferedCh))
    fmt.Printf("有缓冲Channel大小: %d\n", cap(bufferedCh))
    fmt.Printf("Channel元素大小: %d bytes\n", unsafe.Sizeof(int(0)))
    
    // 2. 基本发送和接收操作
    go func() {
        // 发送数据到有缓冲Channel
        for i := 0; i < 3; i++ {
            bufferedCh <- i
            fmt.Printf("发送: %d, 当前长度: %d\n", i, len(bufferedCh))
        }
        close(bufferedCh)
    }()
    
    // 接收数据
    for value := range bufferedCh {
        fmt.Printf("接收: %d\n", value)
        time.Sleep(time.Millisecond * 100)
    }
    
    // 3. 检查Channel状态
    stringCh <- "hello"
    stringCh <- "world"
    
    // 非阻塞接收
    select {
    case msg := <-stringCh:
        fmt.Printf("非阻塞接收: %s\n", msg)
    default:
        fmt.Println("Channel为空")
    }
    
    // 检查Channel是否关闭
    value, ok := <-stringCh
    if ok {
        fmt.Printf("接收到: %s, Channel状态: 开启\n", value)
    } else {
        fmt.Println("Channel已关闭")
    }
    
    close(stringCh)
    
    // 从已关闭的Channel接收
    value, ok = <-stringCh
    fmt.Printf("从已关闭Channel接收: '%s', ok: %t\n", value, ok)
}

// Channel操作的阻塞行为演示
func channelBlockingBehavior() {
    fmt.Println("\n=== Channel阻塞行为演示 ===")
    
    // 无缓冲Channel的同步特性
    syncCh := make(chan string)
    
    go func() {
        fmt.Println("Goroutine: 准备发送数据")
        syncCh <- "同步消息"  // 阻塞直到有接收者
        fmt.Println("Goroutine: 数据发送完成")
    }()
    
    time.Sleep(time.Second) // 让发送Goroutine先运行
    fmt.Println("主Goroutine: 准备接收数据")
    msg := <-syncCh
    fmt.Printf("主Goroutine: 接收到 '%s'\n", msg)
}
```

#### 9.2.3 无缓冲Channel深入分析

**特点：**
- 发送和接收操作都是阻塞的
- 提供强同步保证
- 适用于需要确保数据被处理的场景

```go
func unbufferedChannelAnalysis() {
    fmt.Println("=== 无缓冲Channel深入分析 ===")
    
    ch := make(chan string)
    done := make(chan bool)
    
    // 演示同步特性
    go func() {
        fmt.Println("接收者: 等待数据...")
        message := <-ch
        fmt.Printf("接收者: 收到消息 '%s'\n", message)
        
        // 发送确认信号
        done <- true
    }()
    
    // 主Goroutine发送数据
    fmt.Println("发送者: 准备发送数据")
    ch <- "Hello from main"  // 阻塞直到有接收者
    fmt.Println("发送者: 数据发送完成")
    
    // 等待处理完成
    <-done
    fmt.Println("主程序: 所有操作完成")
}

// 无缓冲Channel的握手机制
func handshakePattern() {
    fmt.Println("\n=== 握手模式演示 ===")
    
    work := make(chan string)
    ack := make(chan bool)
    
    // 工作者
    go func() {
        for task := range work {
            fmt.Printf("工作者: 处理任务 '%s'\n", task)
            time.Sleep(time.Millisecond * 100) // 模拟处理时间
            ack <- true // 发送确认
        }
    }()
    
    // 发送任务并等待确认
    tasks := []string{"任务1", "任务2", "任务3"}
    for _, task := range tasks {
        work <- task    // 发送任务
        <-ack          // 等待确认
        fmt.Printf("主程序: 任务 '%s' 已完成\n", task)
    }
    
    close(work)
}
```

#### 9.2.4 有缓冲Channel深入分析

**特点：**
- 异步操作，发送方不会立即阻塞
- 缓冲区满时发送阻塞，缓冲区空时接收阻塞
- 适用于生产者-消费者模式

```go
func bufferedChannelAnalysis() {
    fmt.Println("=== 有缓冲Channel深入分析 ===")
    
    // 创建容量为3的缓冲Channel
    ch := make(chan int, 3)
    
    fmt.Printf("初始状态 - 长度: %d, 容量: %d\n", len(ch), cap(ch))
    
    // 非阻塞发送（缓冲区未满）
    for i := 1; i <= 3; i++ {
        ch <- i
        fmt.Printf("发送 %d - 长度: %d, 容量: %d\n", i, len(ch), cap(ch))
    }
    
    // 尝试再发送一个（会阻塞）
    go func() {
        fmt.Println("尝试发送第4个元素（会阻塞）...")
        ch <- 4
        fmt.Println("第4个元素发送成功")
    }()
    
    time.Sleep(time.Millisecond * 100)
    
    // 接收数据，释放缓冲区空间
    for i := 0; i < 4; i++ {
        value := <-ch
        fmt.Printf("接收 %d - 长度: %d, 容量: %d\n", value, len(ch), cap(ch))
        time.Sleep(time.Millisecond * 50)
    }
}

// 缓冲Channel的性能优势演示
func bufferedChannelPerformance() {
    fmt.Println("\n=== 缓冲Channel性能演示 ===")
    
    const numMessages = 1000
    
    // 测试无缓冲Channel
    start := time.Now()
    unbuffered := make(chan int)
    
    go func() {
        for i := 0; i < numMessages; i++ {
            unbuffered <- i
        }
        close(unbuffered)
    }()
    
    for range unbuffered {
        // 接收所有消息
    }
    unbufferedTime := time.Since(start)
    
    // 测试有缓冲Channel
    start = time.Now()
    buffered := make(chan int, 100)
    
    go func() {
        for i := 0; i < numMessages; i++ {
            buffered <- i
        }
        close(buffered)
    }()
    
    for range buffered {
        // 接收所有消息
    }
    bufferedTime := time.Since(start)
    
    fmt.Printf("无缓冲Channel耗时: %v\n", unbufferedTime)
    fmt.Printf("有缓冲Channel耗时: %v\n", bufferedTime)
    fmt.Printf("性能提升: %.2fx\n", float64(unbufferedTime)/float64(bufferedTime))
}
```

#### 9.2.5 Channel方向与类型安全

**Channel方向的作用：**
- 提供编译时类型安全检查
- 明确函数的意图和职责
- 防止误用Channel

```go
// Channel方向演示
func channelDirections() {
    fmt.Println("=== Channel方向演示 ===")
    
    // 创建双向Channel
    ch := make(chan int, 2)
    
    // 启动发送者
    go sender(ch)
    
    // 启动接收者
    go receiver(ch)
    
    time.Sleep(time.Second)
}

// 只发送Channel - 编译器会确保只能发送
func sender(ch chan<- int) {
    fmt.Println("发送者: 开始发送数据")
    for i := 0; i < 3; i++ {
        ch <- i
        fmt.Printf("发送者: 发送 %d\n", i)
        time.Sleep(time.Millisecond * 100)
    }
    close(ch) // 只发送Channel可以关闭
    fmt.Println("发送者: 完成发送并关闭Channel")
}

// 只接收Channel - 编译器会确保只能接收
func receiver(ch <-chan int) {
    fmt.Println("接收者: 开始接收数据")
    for value := range ch {
        fmt.Printf("接收者: 接收到 %d\n", value)
        time.Sleep(time.Millisecond * 150)
    }
    fmt.Println("接收者: Channel已关闭，停止接收")
}

// 双向Channel转换示例
func channelConversion() {
    fmt.Println("\n=== Channel转换演示 ===")
    
    // 双向Channel
    bidirectional := make(chan string, 1)
    
    // 双向Channel可以隐式转换为单向Channel
    go func(sendOnly chan<- string) {
        sendOnly <- "Hello"
    }(bidirectional) // 双向转为只发送
    
    go func(recvOnly <-chan string) {
        msg := <-recvOnly
        fmt.Printf("转换后接收: %s\n", msg)
    }(bidirectional) // 双向转为只接收
    
    time.Sleep(time.Millisecond * 100)
}

// 复杂的Channel方向使用场景
type DataProcessor struct {
    input  <-chan int
    output chan<- int
}

func NewDataProcessor(input <-chan int, output chan<- int) *DataProcessor {
    return &DataProcessor{
        input:  input,
        output: output,
    }
}

func (dp *DataProcessor) Process() {
    for data := range dp.input {
        // 处理数据（例如：平方）
        processed := data * data
        dp.output <- processed
    }
    close(dp.output)
}

func dataProcessingPipeline() {
    fmt.Println("\n=== 数据处理管道演示 ===")
    
    // 创建管道
    input := make(chan int, 5)
    output := make(chan int, 5)
    
    // 创建处理器
    processor := NewDataProcessor(input, output)
    
    // 启动处理器
    go processor.Process()
    
    // 发送数据
    go func() {
        for i := 1; i <= 5; i++ {
            input <- i
            fmt.Printf("输入: %d\n", i)
        }
        close(input)
    }()
    
    // 接收处理结果
    for result := range output {
        fmt.Printf("输出: %d\n", result)
    }
}
```

### 9.3 select语句深度解析

#### 9.3.1 select语句原理与特性

**select语句的特点：**
- 类似于switch，但专门用于Channel操作
- 随机选择可执行的case（公平性）
- 所有case都阻塞时执行default（如果有）
- 没有default且所有case阻塞时，select阻塞

```go
func selectBasics() {
    fmt.Println("=== select基础演示 ===")
    
    ch1 := make(chan string, 1)
    ch2 := make(chan string, 1)
    ch3 := make(chan string, 1)
    
    // 预先发送数据到所有Channel
    ch1 <- "来自ch1的消息"
    ch2 <- "来自ch2的消息" 
    ch3 <- "来自ch3的消息"
    
    // 演示随机选择特性
    for i := 0; i < 5; i++ {
        // 重新填充Channel
        select {
        case ch1 <- fmt.Sprintf("ch1-消息%d", i):
        case ch2 <- fmt.Sprintf("ch2-消息%d", i):
        case ch3 <- fmt.Sprintf("ch3-消息%d", i):
        default:
            fmt.Printf("第%d次: 所有Channel都满了\n", i)
        }
        
        // 随机接收
        select {
        case msg := <-ch1:
            fmt.Printf("第%d次: 从ch1接收: %s\n", i, msg)
        case msg := <-ch2:
            fmt.Printf("第%d次: 从ch2接收: %s\n", i, msg)
        case msg := <-ch3:
            fmt.Printf("第%d次: 从ch3接收: %s\n", i, msg)
        }
    }
}

// 带超时的select
func selectWithTimeout() {
    fmt.Println("\n=== 带超时的select演示 ===")
    
    ch := make(chan string)
    
    // 启动一个延迟发送的Goroutine
    go func() {
        time.Sleep(2 * time.Second)
        ch <- "延迟消息"
    }()
    
    // 使用select实现超时控制
    select {
    case msg := <-ch:
        fmt.Printf("接收到消息: %s\n", msg)
    case <-time.After(1 * time.Second):
        fmt.Println("操作超时")
    }
    
    // 再次尝试，这次超时时间更长
    select {
    case msg := <-ch:
        fmt.Printf("第二次接收到消息: %s\n", msg)
    case <-time.After(3 * time.Second):
        fmt.Println("第二次操作超时")
    }
}

// select的优先级和公平性
func selectFairness() {
    fmt.Println("\n=== select公平性演示 ===")
    
    ch1 := make(chan int, 10)
    ch2 := make(chan int, 10)
    
    // 填充两个Channel
    for i := 0; i < 10; i++ {
        ch1 <- i
        ch2 <- i + 100
    }
    
    // 统计从每个Channel接收的次数
    count1, count2 := 0, 0
    
    for i := 0; i < 20; i++ {
        select {
        case val := <-ch1:
            count1++
            fmt.Printf("从ch1接收: %d\n", val)
        case val := <-ch2:
            count2++
            fmt.Printf("从ch2接收: %d\n", val)
        }
    }
    
    fmt.Printf("ch1接收次数: %d, ch2接收次数: %d\n", count1, count2)
}
```

#### 9.3.2 非阻塞操作与default子句

**default子句的作用：**
- 当所有case都阻塞时立即执行
- 实现非阻塞的Channel操作
- 避免Goroutine无限等待

```go
func nonBlockingOperations() {
    fmt.Println("=== 非阻塞操作演示 ===")
    
    ch := make(chan int, 2)
    
    // 非阻塞发送
    for i := 0; i < 5; i++ {
        select {
        case ch <- i:
            fmt.Printf("非阻塞发送成功: %d\n", i)
        default:
            fmt.Printf("Channel已满，发送 %d 失败\n", i)
        }
    }
    
    fmt.Printf("Channel当前长度: %d\n", len(ch))
    
    // 非阻塞接收
    for i := 0; i < 5; i++ {
        select {
        case value := <-ch:
            fmt.Printf("非阻塞接收成功: %d\n", value)
        default:
            fmt.Printf("Channel为空，第 %d 次接收失败\n", i+1)
        }
    }
}

// 实现Channel的尝试操作
func tryOperations() {
    fmt.Println("\n=== 尝试操作演示 ===")
    
    ch := make(chan string, 1)
    
    // 尝试发送函数
    trySend := func(ch chan<- string, value string) bool {
        select {
        case ch <- value:
            return true
        default:
            return false
        }
    }
    
    // 尝试接收函数
    tryReceive := func(ch <-chan string) (string, bool) {
        select {
        case value := <-ch:
            return value, true
        default:
            return "", false
        }
    }
    
    // 测试尝试操作
    fmt.Printf("尝试发送 'hello': %t\n", trySend(ch, "hello"))
    fmt.Printf("尝试发送 'world': %t\n", trySend(ch, "world"))
    
    if value, ok := tryReceive(ch); ok {
        fmt.Printf("尝试接收成功: %s\n", value)
    } else {
        fmt.Println("尝试接收失败")
    }
    
    if value, ok := tryReceive(ch); ok {
        fmt.Printf("第二次尝试接收成功: %s\n", value)
    } else {
        fmt.Println("第二次尝试接收失败")
    }
}
```

#### 9.3.3 for-select循环模式

**for-select是GO并发编程的经典模式：**
- 持续监听多个Channel
- 实现事件驱动的程序结构
- 优雅处理退出信号

```go
func forSelectPatterns() {
    fmt.Println("=== for-select模式演示 ===")
    
    data := make(chan int)
    quit := make(chan bool)
    done := make(chan bool)
    
    // 数据生产者
    go func() {
        for i := 0; i < 5; i++ {
            data <- i
            fmt.Printf("生产数据: %d\n", i)
            time.Sleep(time.Millisecond * 300)
        }
        quit <- true
    }()
    
    // 数据消费者（使用for-select）
    go func() {
        defer func() { done <- true }()
        
        for {
            select {
            case value := <-data:
                fmt.Printf("消费数据: %d\n", value)
                time.Sleep(time.Millisecond * 200)
            case <-quit:
                fmt.Println("收到退出信号，停止消费")
                return
            case <-time.After(time.Second):
                fmt.Println("超时，没有新数据")
                return
            }
        }
    }()
    
    <-done
    fmt.Println("for-select演示完成")
}

// 高级for-select模式：多路复用
func multiplexingPattern() {
    fmt.Println("\n=== 多路复用模式演示 ===")
    
    // 创建多个输入Channel
    input1 := make(chan string)
    input2 := make(chan string)
    input3 := make(chan string)
    output := make(chan string)
    quit := make(chan bool)
    
    // 多路复用器
    go func() {
        defer close(output)
        
        for {
            select {
            case msg := <-input1:
                output <- fmt.Sprintf("来自input1: %s", msg)
            case msg := <-input2:
                output <- fmt.Sprintf("来自input2: %s", msg)
            case msg := <-input3:
                output <- fmt.Sprintf("来自input3: %s", msg)
            case <-quit:
                fmt.Println("多路复用器退出")
                return
            }
        }
    }()
    
    // 启动多个发送者
    go func() {
        for i := 0; i < 3; i++ {
            input1 <- fmt.Sprintf("消息%d", i)
            time.Sleep(time.Millisecond * 100)
        }
    }()
    
    go func() {
        for i := 0; i < 3; i++ {
            input2 <- fmt.Sprintf("数据%d", i)
            time.Sleep(time.Millisecond * 150)
        }
    }()
    
    go func() {
        for i := 0; i < 3; i++ {
            input3 <- fmt.Sprintf("信息%d", i)
            time.Sleep(time.Millisecond * 200)
        }
    }()
    
    // 接收复用后的输出
    go func() {
        time.Sleep(time.Second)
        quit <- true
    }()
    
    for msg := range output {
        fmt.Println(msg)
    }
}

// 心跳检测模式
func heartbeatPattern() {
    fmt.Println("\n=== 心跳检测模式演示 ===")
    
    heartbeat := time.NewTicker(time.Millisecond * 500)
    work := make(chan string)
    quit := make(chan bool)
    
    defer heartbeat.Stop()
    
    // 工作协程
    go func() {
        tasks := []string{"任务A", "任务B", "任务C"}
        for i, task := range tasks {
            time.Sleep(time.Millisecond * 300)
            work <- task
            if i == len(tasks)-1 {
                quit <- true
            }
        }
    }()
    
    // 主循环
    for {
        select {
        case task := <-work:
            fmt.Printf("处理: %s\n", task)
        case <-heartbeat.C:
            fmt.Println("♥ 心跳")
        case <-quit:
            fmt.Println("工作完成，退出")
            return
        }
    }
}
```

### 9.4 经典并发模式深度解析

#### 9.4.1 生产者-消费者模式

**模式特点：**
- 解耦生产和消费逻辑
- 通过缓冲区平衡生产和消费速度
- 支持多生产者和多消费者

```go
// 基础生产者-消费者模式
func basicProducerConsumer() {
    fmt.Println("=== 基础生产者-消费者模式 ===")
    
    buffer := make(chan int, 5) // 缓冲区大小为5
    done := make(chan bool)
    
    // 生产者
    go func() {
        defer close(buffer)
        for i := 0; i < 10; i++ {
            buffer <- i
            fmt.Printf("生产者: 生产 %d (缓冲区: %d/%d)\n", i, len(buffer), cap(buffer))
            time.Sleep(time.Millisecond * 100)
        }
        fmt.Println("生产者: 生产完成")
    }()
    
    // 消费者
    go func() {
        defer func() { done <- true }()
        for value := range buffer {
            fmt.Printf("消费者: 消费 %d (缓冲区: %d/%d)\n", value, len(buffer), cap(buffer))
            time.Sleep(time.Millisecond * 200) // 消费比生产慢
        }
        fmt.Println("消费者: 消费完成")
    }()
    
    <-done
}

// 多生产者-多消费者模式
func multiProducerConsumer() {
    fmt.Println("\n=== 多生产者-多消费者模式 ===")
    
    const (
        numProducers = 3
        numConsumers = 2
        bufferSize   = 10
        itemsPerProducer = 5
    )
    
    buffer := make(chan int, bufferSize)
    var wg sync.WaitGroup
    
    // 启动多个生产者
    for i := 0; i < numProducers; i++ {
        wg.Add(1)
        go func(producerID int) {
            defer wg.Done()
            for j := 0; j < itemsPerProducer; j++ {
                item := producerID*100 + j
                buffer <- item
                fmt.Printf("生产者%d: 生产 %d\n", producerID, item)
                time.Sleep(time.Millisecond * 50)
            }
            fmt.Printf("生产者%d: 完成\n", producerID)
        }(i)
    }
    
    // 关闭buffer的Goroutine
    go func() {
        wg.Wait()
        close(buffer)
        fmt.Println("所有生产者完成，关闭缓冲区")
    }()
    
    // 启动多个消费者
    var consumerWg sync.WaitGroup
    for i := 0; i < numConsumers; i++ {
        consumerWg.Add(1)
        go func(consumerID int) {
            defer consumerWg.Done()
            for item := range buffer {
                fmt.Printf("消费者%d: 消费 %d\n", consumerID, item)
                time.Sleep(time.Millisecond * 100)
            }
            fmt.Printf("消费者%d: 完成\n", consumerID)
        }(i)
    }
    
    consumerWg.Wait()
    fmt.Println("所有消费者完成")
}

// 带优先级的生产者-消费者模式
func priorityProducerConsumer() {
    fmt.Println("\n=== 优先级生产者-消费者模式 ===")
    
    type PriorityItem struct {
        Value    int
        Priority int
    }
    
    highPriority := make(chan PriorityItem, 5)
    lowPriority := make(chan PriorityItem, 5)
    done := make(chan bool)
    
    // 生产者
    go func() {
        defer func() {
            close(highPriority)
            close(lowPriority)
        }()
        
        for i := 0; i < 10; i++ {
            item := PriorityItem{Value: i, Priority: i % 3}
            
            if item.Priority >= 2 {
                highPriority <- item
                fmt.Printf("高优先级生产: %+v\n", item)
            } else {
                lowPriority <- item
                fmt.Printf("低优先级生产: %+v\n", item)
            }
            time.Sleep(time.Millisecond * 100)
        }
    }()
    
    // 优先级消费者
    go func() {
        defer func() { done <- true }()
        
        for {
            select {
            case item, ok := <-highPriority:
                if !ok {
                    highPriority = nil
                } else {
                    fmt.Printf("优先处理高优先级: %+v\n", item)
                    time.Sleep(time.Millisecond * 50)
                }
            case item, ok := <-lowPriority:
                if !ok {
                    lowPriority = nil
                } else {
                    fmt.Printf("处理低优先级: %+v\n", item)
                    time.Sleep(time.Millisecond * 100)
                }
            }
            
            if highPriority == nil && lowPriority == nil {
                break
            }
        }
    }()
    
    <-done
}
```

#### 9.4.2 工作池模式

**模式特点：**
- 限制并发Goroutine数量
- 复用Goroutine，避免频繁创建销毁
- 适用于CPU密集型或需要限制资源使用的场景

```go
// 基础工作池模式
func basicWorkerPool() {
    fmt.Println("=== 基础工作池模式 ===")
    
    const (
        numWorkers = 3
        numJobs    = 10
    )
    
    jobs := make(chan int, numJobs)
    results := make(chan int, numJobs)
    
    // 启动工作者
    for w := 1; w <= numWorkers; w++ {
        go worker(w, jobs, results)
    }
    
    // 发送任务
    for j := 1; j <= numJobs; j++ {
        jobs <- j
    }
    close(jobs)
    
    // 收集结果
    for r := 1; r <= numJobs; r++ {
        result := <-results
        fmt.Printf("收到结果: %d\n", result)
    }
}

func worker(id int, jobs <-chan int, results chan<- int) {
    for job := range jobs {
        fmt.Printf("工作者 %d 开始任务 %d\n", id, job)
        time.Sleep(time.Millisecond * 500) // 模拟工作
        result := job * job
        fmt.Printf("工作者 %d 完成任务 %d，结果: %d\n", id, job, result)
        results <- result
    }
    fmt.Printf("工作者 %d 退出\n", id)
}

// 高级工作池：支持动态调整和监控
type WorkerPool struct {
    workerCount int
    jobs        chan Job
    results     chan Result
    quit        chan bool
    wg          sync.WaitGroup
}

type Job struct {
    ID   int
    Data interface{}
}

type Result struct {
    JobID int
    Data  interface{}
    Error error
}

func NewWorkerPool(workerCount int) *WorkerPool {
    return &WorkerPool{
        workerCount: workerCount,
        jobs:        make(chan Job, workerCount*2),
        results:     make(chan Result, workerCount*2),
        quit:        make(chan bool),
    }
}

func (wp *WorkerPool) Start() {
    for i := 0; i < wp.workerCount; i++ {
        wp.wg.Add(1)
        go wp.advancedWorker(i)
    }
}

func (wp *WorkerPool) Stop() {
    close(wp.quit)
    wp.wg.Wait()
    close(wp.results)
}

func (wp *WorkerPool) Submit(job Job) {
    wp.jobs <- job
}

func (wp *WorkerPool) Results() <-chan Result {
    return wp.results
}

func (wp *WorkerPool) advancedWorker(id int) {
    defer wp.wg.Done()
    
    for {
        select {
        case job := <-wp.jobs:
            fmt.Printf("高级工作者 %d 处理任务 %d\n", id, job.ID)
            
            // 模拟不同类型的工作
            var result Result
            result.JobID = job.ID
            
            switch data := job.Data.(type) {
            case int:
                result.Data = data * data
                time.Sleep(time.Millisecond * 200)
            case string:
                result.Data = strings.ToUpper(data)
                time.Sleep(time.Millisecond * 100)
            default:
                result.Error = fmt.Errorf("不支持的数据类型: %T", data)
            }
            
            wp.results <- result
            fmt.Printf("高级工作者 %d 完成任务 %d\n", id, job.ID)
            
        case <-wp.quit:
            fmt.Printf("高级工作者 %d 收到退出信号\n", id)
            return
        }
    }
}

func advancedWorkerPoolDemo() {
    fmt.Println("\n=== 高级工作池演示 ===")
    
    pool := NewWorkerPool(3)
    pool.Start()
    
    // 提交不同类型的任务
    jobs := []Job{
        {ID: 1, Data: 5},
        {ID: 2, Data: "hello"},
        {ID: 3, Data: 10},
        {ID: 4, Data: "world"},
        {ID: 5, Data: 15},
    }
    
    // 启动结果收集器
    go func() {
        for result := range pool.Results() {
            if result.Error != nil {
                fmt.Printf("任务 %d 失败: %v\n", result.JobID, result.Error)
            } else {
                fmt.Printf("任务 %d 结果: %v\n", result.JobID, result.Data)
            }
        }
    }()
    
    // 提交任务
    for _, job := range jobs {
        pool.Submit(job)
    }
    
    time.Sleep(2 * time.Second)
    pool.Stop()
}

// 带限流的工作池
func rateLimitedWorkerPool() {
    fmt.Println("\n=== 限流工作池演示 ===")
    
    const (
        numWorkers = 2
        rateLimit  = 3 // 每秒最多处理3个任务
    )
    
    jobs := make(chan int, 10)
    results := make(chan int, 10)
    
    // 限流器
    limiter := time.NewTicker(time.Second / rateLimit)
    defer limiter.Stop()
    
    // 启动限流工作者
    for i := 0; i < numWorkers; i++ {
        go func(workerID int) {
            for job := range jobs {
                <-limiter.C // 等待限流器允许
                fmt.Printf("限流工作者 %d 处理任务 %d\n", workerID, job)
                time.Sleep(time.Millisecond * 100)
                results <- job * 2
            }
        }(i)
    }
    
    // 发送任务
    go func() {
        for i := 1; i <= 10; i++ {
            jobs <- i
        }
        close(jobs)
    }()
    
    // 收集结果
    for i := 0; i < 10; i++ {
        result := <-results
        fmt.Printf("限流结果: %d\n", result)
    }
}
```
```

#### 9.4.3 扇入扇出模式
```go
// 扇出：一个输入分发到多个输出
func fanOut(input <-chan int) (<-chan int, <-chan int) {
    out1 := make(chan int)
    out2 := make(chan int)
    
    go func() {
        defer close(out1)
        defer close(out2)
        
        for value := range input {
            out1 <- value
            out2 <- value
        }
    }()
    
    return out1, out2
}

// 扇入：多个输入合并到一个输出
func fanIn(input1, input2 <-chan int) <-chan int {
    output := make(chan int)
    
    go func() {
        defer close(output)
        
        for {
            select {
            case value, ok := <-input1:
                if !ok {
                    input1 = nil
                } else {
                    output <- value
                }
            case value, ok := <-input2:
                if !ok {
                    input2 = nil
                } else {
                    output <- value
                }
            }
            
            if input1 == nil && input2 == nil {
                break
            }
        }
    }()
    
    return output
}
```

### 9.5 Context包深度解析

#### 9.5.1 Context概念与设计原理

**Context的作用：**
- 传递请求范围的值
- 传递取消信号
- 传递超时信息
- 在Goroutine之间传播截止时间

**Context接口定义：**
```go
type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
```

#### 9.5.2 Context的四种类型

```go
import (
    "context"
    "fmt"
    "time"
)

// 1. Background Context - 根Context
func backgroundContext() {
    fmt.Println("=== Background Context演示 ===")
    
    ctx := context.Background()
    fmt.Printf("Background Context: %+v\n", ctx)
    
    // Background Context永远不会被取消
    select {
    case <-ctx.Done():
        fmt.Println("Background Context被取消") // 永远不会执行
    default:
        fmt.Println("Background Context永远不会被取消")
    }
}

// 2. WithCancel - 可取消的Context
func cancelContext() {
    fmt.Println("\n=== WithCancel演示 ===")
    
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel() // 确保资源清理
    
    go func() {
        for i := 0; i < 5; i++ {
            select {
            case <-ctx.Done():
                fmt.Printf("工作被取消: %v\n", ctx.Err())
                return
            default:
                fmt.Printf("工作进行中... %d\n", i)
                time.Sleep(time.Millisecond * 500)
            }
        }
        fmt.Println("工作正常完成")
    }()
    
    // 2秒后取消
    time.Sleep(2 * time.Second)
    cancel()
    time.Sleep(time.Second) // 等待Goroutine退出
}

// 3. WithTimeout - 带超时的Context
func timeoutContext() {
    fmt.Println("\n=== WithTimeout演示 ===")
    
    // 设置3秒超时
    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
    defer cancel()
    
    go func() {
        for i := 0; i < 10; i++ {
            select {
            case <-ctx.Done():
                fmt.Printf("操作超时: %v\n", ctx.Err())
                return
            default:
                fmt.Printf("处理任务 %d\n", i)
                time.Sleep(time.Millisecond * 800)
            }
        }
        fmt.Println("所有任务完成")
    }()
    
    <-ctx.Done()
    fmt.Printf("主程序收到超时信号: %v\n", ctx.Err())
}

// 4. WithDeadline - 带截止时间的Context
func deadlineContext() {
    fmt.Println("\n=== WithDeadline演示 ===")
    
    deadline := time.Now().Add(2 * time.Second)
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()
    
    go func() {
        for {
            select {
            case <-ctx.Done():
                if deadline, ok := ctx.Deadline(); ok {
                    fmt.Printf("截止时间到达: %v, 错误: %v\n", deadline, ctx.Err())
                }
                return
            default:
                fmt.Println("执行任务...")
                time.Sleep(time.Millisecond * 500)
            }
        }
    }()
    
    <-ctx.Done()
}

// 5. WithValue - 传递值的Context
func valueContext() {
    fmt.Println("\n=== WithValue演示 ===")
    
    type key string
    const userKey key = "user"
    const requestIDKey key = "requestID"
    
    // 创建带值的Context
    ctx := context.WithValue(context.Background(), userKey, "Alice")
    ctx = context.WithValue(ctx, requestIDKey, "req-123")
    
    processRequest(ctx)
}

func processRequest(ctx context.Context) {
    type key string
    const userKey key = "user"
    const requestIDKey key = "requestID"
    
    user := ctx.Value(userKey)
    requestID := ctx.Value(requestIDKey)
    
    fmt.Printf("处理请求 - 用户: %v, 请求ID: %v\n", user, requestID)
    
    // 传递给下一层
    authenticateUser(ctx)
}

func authenticateUser(ctx context.Context) {
    type key string
    const userKey key = "user"
    
    if user := ctx.Value(userKey); user != nil {
        fmt.Printf("认证用户: %v\n", user)
    } else {
        fmt.Println("未找到用户信息")
    }
}
```

#### 9.5.3 Context的最佳实践

```go
// HTTP服务器中的Context使用
func httpServerWithContext() {
    fmt.Println("\n=== HTTP服务器Context演示 ===")
    
    // 模拟HTTP请求处理
    handleRequest := func(ctx context.Context, userID string) error {
        // 设置请求超时
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()
        
        // 模拟数据库查询
        return queryDatabase(ctx, userID)
    }
    
    // 模拟请求
    ctx := context.Background()
    if err := handleRequest(ctx, "user123"); err != nil {
        fmt.Printf("请求处理失败: %v\n", err)
    }
}

func queryDatabase(ctx context.Context, userID string) error {
    // 模拟数据库查询
    resultCh := make(chan error, 1)
    
    go func() {
        // 模拟耗时操作
        time.Sleep(2 * time.Second)
        resultCh <- nil // 查询成功
    }()
    
    select {
    case err := <-resultCh:
        if err != nil {
            return fmt.Errorf("数据库查询失败: %w", err)
        }
        fmt.Printf("成功查询用户: %s\n", userID)
        return nil
    case <-ctx.Done():
        return fmt.Errorf("数据库查询被取消: %w", ctx.Err())
    }
}

// Context链式传播
func contextPropagation() {
    fmt.Println("\n=== Context传播演示 ===")
    
    // 根Context
    rootCtx := context.Background()
    
    // 第一层：添加超时
    ctx1, cancel1 := context.WithTimeout(rootCtx, 5*time.Second)
    defer cancel1()
    
    // 第二层：添加取消
    ctx2, cancel2 := context.WithCancel(ctx1)
    defer cancel2()
    
    // 第三层：添加值
    type key string
    ctx3 := context.WithValue(ctx2, key("level"), "3")
    
    // 启动工作
    go worker(ctx3, "Worker-1")
    go worker(ctx3, "Worker-2")
    
    // 2秒后取消
    time.Sleep(2 * time.Second)
    cancel2() // 取消会传播到所有子Context
    
    time.Sleep(time.Second)
}

func worker(ctx context.Context, name string) {
    type key string
    level := ctx.Value(key("level"))
    
    for i := 0; i < 10; i++ {
        select {
        case <-ctx.Done():
            fmt.Printf("%s 收到取消信号 (level: %v): %v\n", name, level, ctx.Err())
            return
        default:
            fmt.Printf("%s 工作中... %d\n", name, i)
            time.Sleep(time.Millisecond * 500)
        }
    }
}

// Context使用陷阱和注意事项
func contextPitfalls() {
    fmt.Println("\n=== Context使用陷阱演示 ===")
    
    // 陷阱1：不要将Context存储在结构体中
    type BadService struct {
        ctx context.Context // 不推荐
    }
    
    // 正确做法：将Context作为参数传递
    type GoodService struct {
        // 其他字段
    }
    
    goodService := &GoodService{}
    ctx := context.Background()
    goodService.ProcessData(ctx, "data")
}

func (s *GoodService) ProcessData(ctx context.Context, data string) {
    // 正确的Context使用方式
    fmt.Printf("处理数据: %s\n", data)
}
```

### 9.6 并发安全深度解析

#### 9.6.1 竞态条件的本质与检测

**什么是竞态条件？**
当多个Goroutine同时访问共享资源，且至少有一个进行写操作时，就可能发生竞态条件。

```go
import (
    "fmt"
    "runtime"
    "sync"
    "sync/atomic"
    "time"
)

// 演示竞态条件
func demonstrateRaceCondition() {
    fmt.Println("=== 竞态条件演示 ===")
    
    var counter int
    var wg sync.WaitGroup
    
    // 启动多个Goroutine同时修改counter
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            // 这里存在竞态条件
            temp := counter
            temp++
            counter = temp
        }()
    }
    
    wg.Wait()
    fmt.Printf("期望结果: 1000, 实际结果: %d\n", counter)
    
    // 使用竞态检测器运行: go run -race main.go
}

// 使用竞态检测器
func raceDetectionExample() {
    fmt.Println("\n=== 竞态检测器使用 ===")
    
    var data int
    
    go func() {
        data = 1 // 写操作
    }()
    
    go func() {
        fmt.Println(data) // 读操作，可能发生竞态
    }()
    
    time.Sleep(time.Millisecond * 100)
}
```

#### 9.6.2 并发安全的解决方案

**1. 使用互斥锁（Mutex）**
```go
// 使用Mutex保证并发安全
type SafeCounter struct {
    mu    sync.Mutex
    value int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.value
}

func mutexExample() {
    fmt.Println("\n=== Mutex并发安全演示 ===")
    
    counter := &SafeCounter{}
    var wg sync.WaitGroup
    
    // 启动多个Goroutine
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }
    
    wg.Wait()
    fmt.Printf("Mutex保护的计数器结果: %d\n", counter.Value())
}

// 读写锁示例
type SafeMap struct {
    mu   sync.RWMutex
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{
        data: make(map[string]int),
    }
}

func (sm *SafeMap) Set(key string, value int) {
    sm.mu.Lock()
    defer sm.mu.Unlock()
    sm.data[key] = value
}

func (sm *SafeMap) Get(key string) (int, bool) {
    sm.mu.RLock()
    defer sm.mu.RUnlock()
    value, ok := sm.data[key]
    return value, ok
}

func rwMutexExample() {
    fmt.Println("\n=== RWMutex演示 ===")
    
    safeMap := NewSafeMap()
    var wg sync.WaitGroup
    
    // 写操作
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            safeMap.Set(key, i)
            fmt.Printf("设置 %s = %d\n", key, i)
        }(i)
    }
    
    // 读操作
    for i := 0; i < 50; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i%10)
            if value, ok := safeMap.Get(key); ok {
                fmt.Printf("读取 %s = %d\n", key, value)
            }
        }(i)
    }
    
    wg.Wait()
}
```

**2. 使用原子操作**
```go
// 原子操作示例
func atomicExample() {
    fmt.Println("\n=== 原子操作演示 ===")
    
    var counter int64
    var wg sync.WaitGroup
    
    // 使用原子操作
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    
    wg.Wait()
    fmt.Printf("原子操作计数器结果: %d\n", atomic.LoadInt64(&counter))
}

// 原子操作的高级用法
type AtomicBool struct {
    flag int32
}

func (ab *AtomicBool) Set(value bool) {
    var i int32 = 0
    if value {
        i = 1
    }
    atomic.StoreInt32(&ab.flag, i)
}

func (ab *AtomicBool) Get() bool {
    return atomic.LoadInt32(&ab.flag) != 0
}

func (ab *AtomicBool) CompareAndSwap(old, new bool) bool {
    var oldVal, newVal int32
    if old {
        oldVal = 1
    }
    if new {
        newVal = 1
    }
    return atomic.CompareAndSwapInt32(&ab.flag, oldVal, newVal)
}

func atomicBoolExample() {
    fmt.Println("\n=== 原子布尔值演示 ===")
    
    flag := &AtomicBool{}
    var wg sync.WaitGroup
    
    // 多个Goroutine尝试设置标志
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            // 尝试从false设置为true
            if flag.CompareAndSwap(false, true) {
                fmt.Printf("Goroutine %d 成功设置标志\n", id)
                time.Sleep(time.Millisecond * 100)
                flag.Set(false) // 重置标志
            } else {
                fmt.Printf("Goroutine %d 设置标志失败\n", id)
            }
        }(i)
    }
    
    wg.Wait()
}
```

**3. 使用Channel保证安全**
```go
// Channel作为互斥锁
func channelMutexExample() {
    fmt.Println("\n=== Channel互斥锁演示 ===")
    
    // 使用容量为1的Channel作为互斥锁
    mutex := make(chan struct{}, 1)
    mutex <- struct{}{} // 初始化锁
    
    var counter int
    var wg sync.WaitGroup
    
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            
            // 获取锁
            <-mutex
            
            // 临界区
            counter++
            
            // 释放锁
            mutex <- struct{}{}
        }()
    }
    
    wg.Wait()
    fmt.Printf("Channel互斥锁计数器结果: %d\n", counter)
}

// 使用Channel实现信号量
type Semaphore struct {
    ch chan struct{}
}

func NewSemaphore(capacity int) *Semaphore {
    return &Semaphore{
        ch: make(chan struct{}, capacity),
    }
}

func (s *Semaphore) Acquire() {
    s.ch <- struct{}{}
}

func (s *Semaphore) Release() {
    <-s.ch
}

func semaphoreExample() {
    fmt.Println("\n=== 信号量演示 ===")
    
    // 限制同时运行的Goroutine数量为3
    sem := NewSemaphore(3)
    var wg sync.WaitGroup
    
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            
            sem.Acquire()
            defer sem.Release()
            
            fmt.Printf("Goroutine %d 开始工作\n", id)
            time.Sleep(time.Second)
            fmt.Printf("Goroutine %d 完成工作\n", id)
        }(i)
    }
    
    wg.Wait()
}
```

#### 9.6.3 并发安全的数据结构

```go
// 并发安全的队列
type SafeQueue struct {
    mu    sync.Mutex
    items []interface{}
}

func NewSafeQueue() *SafeQueue {
    return &SafeQueue{
        items: make([]interface{}, 0),
    }
}

func (q *SafeQueue) Enqueue(item interface{}) {
    q.mu.Lock()
    defer q.mu.Unlock()
    q.items = append(q.items, item)
}

func (q *SafeQueue) Dequeue() (interface{}, bool) {
    q.mu.Lock()
    defer q.mu.Unlock()
    
    if len(q.items) == 0 {
        return nil, false
    }
    
    item := q.items[0]
    q.items = q.items[1:]
    return item, true
}

func (q *SafeQueue) Size() int {
    q.mu.Lock()
    defer q.mu.Unlock()
    return len(q.items)
}

// 使用sync.Map的并发安全映射
func syncMapExample() {
    fmt.Println("\n=== sync.Map演示 ===")
    
    var sm sync.Map
    var wg sync.WaitGroup
    
    // 并发写入
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            sm.Store(key, i)
        }(i)
    }
    
    // 并发读取
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func(i int) {
            defer wg.Done()
            key := fmt.Sprintf("key%d", i)
            if value, ok := sm.Load(key); ok {
                fmt.Printf("读取到 %s: %v\n", key, value)
            }
        }(i)
    }
    
    wg.Wait()
    
    // 遍历所有键值对
    sm.Range(func(key, value interface{}) bool {
        fmt.Printf("遍历: %v = %v\n", key, value)
        return true
    })
}
```

#### 9.6.4 性能对比与选择指南

```go
// 性能对比测试
func performanceComparison() {
    fmt.Println("\n=== 性能对比测试 ===")
    
    const iterations = 1000000
    
    // 测试Mutex
    start := time.Now()
    testMutex(iterations)
    mutexTime := time.Since(start)
    
    // 测试原子操作
    start = time.Now()
    testAtomic(iterations)
    atomicTime := time.Since(start)
    
    // 测试Channel
    start = time.Now()
    testChannel(iterations)
    channelTime := time.Since(start)
    
    fmt.Printf("Mutex耗时: %v\n", mutexTime)
    fmt.Printf("原子操作耗时: %v\n", atomicTime)
    fmt.Printf("Channel耗时: %v\n", channelTime)
}

func testMutex(iterations int) {
    var mu sync.Mutex
    var counter int
    var wg sync.WaitGroup
    
    for i := 0; i < iterations; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    wg.Wait()
}

func testAtomic(iterations int) {
    var counter int64
    var wg sync.WaitGroup
    
    for i := 0; i < iterations; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt64(&counter, 1)
        }()
    }
    wg.Wait()
}

func testChannel(iterations int) {
    ch := make(chan struct{}, 1)
    ch <- struct{}{}
    var counter int
    var wg sync.WaitGroup
    
    for i := 0; i < iterations; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            <-ch
            counter++
            ch <- struct{}{}
        }()
    }
    wg.Wait()
}
```

### 9.7 常见陷阱

#### 9.7.1 Goroutine泄漏
```go
// 错误：Goroutine可能永远阻塞
func goroutineLeak() {
    ch := make(chan int)
    
    go func() {
        ch <- 42 // 如果没有接收者，会永远阻塞
    }()
    
    // 主函数退出，但Goroutine仍在运行
}

// 正确：使用缓冲Channel或确保有接收者
func fixedGoroutineLeak() {
    ch := make(chan int, 1) // 缓冲Channel
    
    go func() {
        ch <- 42
    }()
    
    value := <-ch
    fmt.Println(value)
}
```

#### 9.7.2 Channel关闭陷阱
```go
// 检查Channel是否关闭
func checkChannelClosed() {
    ch := make(chan int, 2)
    ch <- 1
    ch <- 2
    close(ch)
    
    for {
        value, ok := <-ch
        if !ok {
            fmt.Println("Channel已关闭")
            break
        }
        fmt.Println("接收到:", value)
    }
}
```

## 🎯 大厂面试重点

### 核心概念理解
1. **Goroutine vs 线程的本质区别**
   - 内存占用：Goroutine初始栈2KB vs 线程1-2MB
   - 调度方式：用户态调度 vs 内核态调度
   - 创建成本：Goroutine微秒级 vs 线程毫秒级
   - 上下文切换：Goroutine纳秒级 vs 线程微秒级

2. **GMP调度模型深度理解**
   - G（Goroutine）：用户态轻量级线程
   - M（Machine）：操作系统线程
   - P（Processor）：逻辑处理器，维护本地队列
   - 工作窃取算法、抢占式调度、系统调用处理

3. **Channel底层实现原理**
   - hchan结构体：环形队列、等待队列、锁机制
   - 发送和接收的具体流程
   - 缓冲区满/空时的阻塞机制
   - Channel关闭的处理逻辑

### 高频面试题

#### 1. Goroutine泄漏场景及解决方案
```go
// 常见泄漏场景1：Channel阻塞
func goroutineLeakExample1() {
    ch := make(chan int)
    go func() {
        ch <- 1 // 永远阻塞，没有接收者
    }()
    // 解决方案：使用缓冲Channel或确保有接收者
}

// 常见泄漏场景2：无限循环
func goroutineLeakExample2() {
    go func() {
        for {
            // 没有退出条件的无限循环
            time.Sleep(time.Second)
        }
    }()
    // 解决方案：使用Context或quit Channel
}

// 正确的实现
func correctImplementation() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    go func() {
        for {
            select {
            case <-ctx.Done():
                return // 正确退出
            default:
                // 执行工作
                time.Sleep(time.Second)
            }
        }
    }()
}
```

#### 2. Channel使用的最佳实践
```go
// 面试题：实现一个支持超时的Channel操作
func channelWithTimeout[T any](ch chan T, timeout time.Duration) (T, bool) {
    select {
    case value := <-ch:
        return value, true
    case <-time.After(timeout):
        var zero T
        return zero, false
    }
}

// 面试题：实现Channel的扇入模式
func fanIn[T any](channels ...<-chan T) <-chan T {
    out := make(chan T)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan T) {
            defer wg.Done()
            for value := range c {
                out <- value
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

#### 3. 并发安全问题
```go
// 面试题：分析并发安全问题
type Counter struct {
    mu    sync.RWMutex
    value int64
}

func (c *Counter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.value++
}

func (c *Counter) Value() int64 {
    c.mu.RLock()
    defer c.mu.RUnlock()
    return c.value
}

// 使用原子操作的版本
type AtomicCounter struct {
    value int64
}

func (c *AtomicCounter) Increment() {
    atomic.AddInt64(&c.value, 1)
}

func (c *AtomicCounter) Value() int64 {
    return atomic.LoadInt64(&c.value)
}
```

### 性能优化要点
1. **选择合适的Channel类型**
   - 无缓冲：强同步，适用于确保数据被处理
   - 有缓冲：异步，适用于生产者-消费者模式

2. **避免过度创建Goroutine**
   - 使用工作池模式限制并发数
   - 复用Goroutine而不是频繁创建

3. **正确使用Context**
   - 传递取消信号和超时控制
   - 避免Context值传递过多数据

## 🚀 实践练习

### 初级练习
1. **并发安全计数器**
   ```go
   // 要求：实现一个支持并发的计数器，支持增加、减少、获取值操作
   // 考察点：互斥锁、原子操作、并发安全
   ```

2. **简单生产者-消费者**
   ```go
   // 要求：实现一个生产者-消费者模式，支持多个生产者和消费者
   // 考察点：Channel使用、Goroutine协调
   ```

### 中级练习
3. **带超时的HTTP客户端**
   ```go
   // 要求：实现一个支持超时、重试、并发控制的HTTP客户端
   // 考察点：Context使用、select语句、错误处理
   ```

4. **任务调度器**
   ```go
   // 要求：实现一个支持定时任务、优先级、并发限制的调度器
   // 考察点：时间处理、优先队列、工作池模式
   ```

### 高级练习
5. **分布式限流器**
   ```go
   // 要求：实现一个支持令牌桶算法的分布式限流器
   // 考察点：算法实现、并发控制、性能优化
   ```

6. **优雅关闭服务**
   ```go
   // 要求：实现一个支持优雅关闭的HTTP服务器
   // 考察点：信号处理、Context传播、资源清理
   ```

### 实战项目
7. **并发爬虫系统**
   - 支持URL去重、并发控制、失败重试
   - 实现生产者-消费者模式
   - 支持优雅关闭和状态监控

8. **实时消息系统**
   - 支持多房间、用户管理
   - 实现消息广播、私聊功能
   - 使用Channel实现消息路由

## 📚 扩展阅读

### 推荐资源
1. **官方文档**
   - [Go Memory Model](https://golang.org/ref/mem)
   - [Effective Go - Concurrency](https://golang.org/doc/effective_go.html#concurrency)

2. **深度文章**
   - "Go's Work-Stealing Scheduler"
   - "Understanding Channels"
   - "The Go Memory Model"

3. **开源项目学习**
   - Kubernetes调度器
   - Docker容器运行时
   - etcd分布式存储

### 性能分析工具
- `go tool pprof`：性能分析
- `go tool trace`：执行跟踪
- `go run -race`：竞态检测

## 📝 章节总结

### 核心知识点回顾
1. **Goroutine**：GO语言的轻量级线程，基于GMP调度模型实现高效并发
2. **Channel**：基于CSP模型的通信机制，实现"通过通信来共享内存"
3. **select语句**：多路复用Channel操作，实现非阻塞和超时控制
4. **Context包**：传递取消信号、超时和请求范围的值
5. **并发模式**：生产者-消费者、工作池、扇入扇出等经典模式

### 最佳实践总结
- **避免共享状态**：优先使用Channel而不是共享变量
- **合理使用缓冲**：根据场景选择无缓冲或有缓冲Channel
- **防止泄漏**：确保Goroutine有明确的退出条件
- **控制并发数**：使用工作池模式限制Goroutine数量
- **优雅关闭**：使用Context实现取消和超时控制

### 常见陷阱提醒
- Channel操作可能导致死锁
- 忘记关闭Channel导致Goroutine泄漏
- 在已关闭的Channel上发送数据会panic
- select语句的随机性可能影响程序行为
- 过度创建Goroutine可能导致性能问题

### 进阶学习方向
- 深入理解GO内存模型
- 学习高级并发模式（如Pipeline、Fan-out/Fan-in）
- 掌握性能调优技巧
- 研究分布式系统中的并发控制
- 学习其他并发原语（sync包）

---

**下一章预告**：第10章将深入探讨高级并发模式，包括Pipeline模式、错误处理、并发测试等更复杂的并发编程技巧。 