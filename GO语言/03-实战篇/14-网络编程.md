# 第14章：网络编程

## 章节概要
本章全面介绍GO语言的网络编程技术，包括TCP/UDP编程、HTTP客户端和服务器开发、WebSocket通信以及网络安全等内容。网络编程是GO语言的强项之一，其优雅的并发模型和丰富的标准库使得开发高性能网络应用变得简单高效。

## 学习目标
- 掌握GO语言网络编程基础及核心包的使用
- 理解TCP/UDP协议的实现原理及区别
- 学会开发高性能、可扩展的网络应用
- 掌握网络安全最佳实践和性能优化技巧
- 能够设计并实现高并发网络服务架构

## 主要内容

### 14.1 网络编程基础

#### 14.1.1 网络协议栈概述
网络协议栈是按照层次化设计的通信协议集合，主要分为以下几层：
- **物理层**：负责比特流的传输
- **数据链路层**：负责物理寻址和差错检测
- **网络层**：负责逻辑寻址和路由选择（如IP协议）
- **传输层**：负责端到端的连接和可靠传输（如TCP、UDP协议）
- **应用层**：负责应用程序间的数据交换（如HTTP、FTP、SMTP等）

GO语言网络编程主要关注传输层和应用层的实现。

#### 14.1.2 GO语言net包介绍
GO语言的标准库提供了丰富的网络编程支持，核心包包括：
- **net**：提供基本的网络I/O接口，包括TCP/IP、UDP、域名解析等
- **net/http**：提供HTTP客户端和服务器实现
- **net/url**：URL解析和查询功能
- **net/rpc**：远程过程调用
- **net/smtp**：简单邮件传输协议客户端

```go
// net包的基本导入方式
import (
    "net"
    "net/http"
    "net/url"
)
```

#### 14.1.3 网络地址和端口处理
在GO语言中，网络地址通常由`net.IP`、`net.IPNet`和`net.Addr`等类型表示：

```go
// IP地址解析
ip := net.ParseIP("192.168.1.1")
if ip != nil {
    fmt.Println("IP:", ip)
}

// 解析CIDR表示法的IP网络
_, ipNet, err := net.ParseCIDR("192.168.1.0/24")
if err == nil {
    fmt.Println("IP网络:", ipNet)
    fmt.Println("掩码:", ipNet.Mask)
}

// 解析和构造网络地址
tcpAddr, err := net.ResolveTCPAddr("tcp", "localhost:8080")
if err == nil {
    fmt.Println("TCP地址:", tcpAddr.IP, "端口:", tcpAddr.Port)
}
```

#### 14.1.4 网络连接的生命周期
GO语言中的网络连接通常遵循以下生命周期：
1. **创建**：通过`Dial`或`Listen`等函数创建连接
2. **配置**：设置超时、缓冲区大小等参数
3. **数据传输**：读写数据
4. **关闭**：调用`Close`方法释放资源

```go
// 典型的客户端连接生命周期
conn, err := net.Dial("tcp", "example.com:80")
if err != nil {
    // 处理连接错误
    return
}
defer conn.Close() // 确保连接最终被关闭

// 设置连接参数
conn.SetDeadline(time.Now().Add(10 * time.Second))

// 数据传输
fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
buf := make([]byte, 4096)
n, err := conn.Read(buf)
// 处理读取到的数据
```

### 14.2 TCP编程

#### 14.2.1 TCP服务器开发
TCP（传输控制协议）是一种面向连接的、可靠的传输层协议。GO语言中实现TCP服务器的基本步骤：

1. 创建监听器
2. 接受客户端连接
3. 处理连接（通常在独立的goroutine中）
4. 关闭连接

```go
// 简单的TCP服务器实现
func startTCPServer() error {
    // 创建TCP监听器
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        return err
    }
    defer listener.Close()
    
    fmt.Println("TCP服务器启动，监听端口 8080...")
    
    for {
        // 接受客户端连接
        conn, err := listener.Accept()
        if err != nil {
            fmt.Println("接受连接错误:", err)
            continue
        }
        
        // 在goroutine中处理连接
        go handleConnection(conn)
    }
}

func handleConnection(conn net.Conn) {
    defer conn.Close()
    
    // 设置连接参数
    conn.SetReadDeadline(time.Now().Add(30 * time.Second))
    
    // 读取客户端数据
    buffer := make([]byte, 1024)
    n, err := conn.Read(buffer)
    if err != nil {
        fmt.Println("读取数据错误:", err)
        return
    }
    
    // 处理数据并回复
    message := string(buffer[:n])
    fmt.Printf("收到消息: %s\n", message)
    
    // 回复客户端
    conn.Write([]byte("已收到消息: " + message))
}
```

#### 14.2.2 TCP客户端实现
TCP客户端的基本实现步骤：
1. 建立与服务器的连接
2. 发送数据
3. 接收响应
4. 关闭连接

```go
// 简单的TCP客户端实现
func tcpClient() error {
    // 连接服务器
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        return err
    }
    defer conn.Close()
    
    // 发送数据
    _, err = conn.Write([]byte("Hello, TCP Server!"))
    if err != nil {
        return err
    }
    
    // 接收响应
    buffer := make([]byte, 1024)
    n, err := conn.Read(buffer)
    if err != nil {
        return err
    }
    
    // 处理响应
    fmt.Printf("服务器响应: %s\n", string(buffer[:n]))
    
    return nil
}
```

#### 14.2.3 连接池管理
在高并发场景下，为了避免频繁创建和销毁连接，通常会使用连接池：

```go
// 一个简单的连接池实现示例
type ConnectionPool struct {
    connections chan net.Conn
    server      string
    mu          sync.Mutex
    maxConn     int
}

func NewConnectionPool(server string, maxConn int) *ConnectionPool {
    return &ConnectionPool{
        connections: make(chan net.Conn, maxConn),
        server:      server,
        maxConn:     maxConn,
    }
}

func (p *ConnectionPool) Get() (net.Conn, error) {
    select {
    case conn := <-p.connections:
        return conn, nil
    default:
        return net.Dial("tcp", p.server)
    }
}

func (p *ConnectionPool) Put(conn net.Conn) {
    select {
    case p.connections <- conn:
        // 连接放回池中
    default:
        // 池已满，直接关闭连接
        conn.Close()
    }
}

func (p *ConnectionPool) Close() {
    p.mu.Lock()
    defer p.mu.Unlock()
    
    close(p.connections)
    for conn := range p.connections {
        conn.Close()
    }
}
```

#### 14.2.4 长连接和短连接
- **短连接**：每次通信后关闭连接，适用于简单的请求-响应模式
- **长连接**：保持连接不断开，可进行多次通信，需要处理心跳、超时和断线重连

长连接实现关键点：
1. 心跳机制维持连接活跃
2. 设置适当的读写超时
3. 处理连接断开和重连

```go
// 长连接客户端示例
func longLiveTCPClient() {
    var conn net.Conn
    var err error
    
    // 连接服务器
    connect := func() (net.Conn, error) {
        return net.Dial("tcp", "localhost:8080")
    }
    
    // 初始连接
    conn, err = connect()
    if err != nil {
        fmt.Println("连接失败:", err)
        return
    }
    
    // 清理资源
    defer conn.Close()
    
    // 启动心跳协程
    stopHeartbeat := make(chan struct{})
    defer close(stopHeartbeat)
    
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                // 发送心跳包
                _, err := conn.Write([]byte("PING"))
                if err != nil {
                    fmt.Println("心跳发送失败:", err)
                    // 尝试重连
                    newConn, err := connect()
                    if err == nil {
                        conn = newConn
                    }
                }
            case <-stopHeartbeat:
                return
            }
        }
    }()
    
    // 主通信逻辑
    buffer := make([]byte, 1024)
    for {
        // 设置读取超时
        conn.SetReadDeadline(time.Now().Add(5 * time.Minute))
        
        n, err := conn.Read(buffer)
        if err != nil {
            if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
                // 处理超时
                continue
            } else {
                // 处理其他错误
                fmt.Println("读取错误:", err)
                // 尝试重连
                newConn, err := connect()
                if err == nil {
                    conn = newConn
                    continue
                }
                break
            }
        }
        
        // 处理接收到的数据
        fmt.Printf("收到: %s\n", string(buffer[:n]))
    }
}
```

### 14.3 UDP编程

#### 14.3.1 UDP服务器和客户端
UDP（用户数据报协议）是一种无连接的传输层协议，不保证可靠传输，但速度快、开销小。

UDP服务器实现：
```go
// UDP服务器示例
func startUDPServer() error {
    // 解析UDP地址
    addr, err := net.ResolveUDPAddr("udp", ":8081")
    if err != nil {
        return err
    }
    
    // 创建UDP连接
    conn, err := net.ListenUDP("udp", addr)
    if err != nil {
        return err
    }
    defer conn.Close()
    
    fmt.Println("UDP服务器启动，监听端口 8081...")
    
    buffer := make([]byte, 1024)
    for {
        // 读取数据
        n, remoteAddr, err := conn.ReadFromUDP(buffer)
        if err != nil {
            fmt.Println("读取数据错误:", err)
            continue
        }
        
        message := string(buffer[:n])
        fmt.Printf("从 %v 收到: %s\n", remoteAddr, message)
        
        // 回复客户端
        response := []byte("已收到消息: " + message)
        _, err = conn.WriteToUDP(response, remoteAddr)
        if err != nil {
            fmt.Println("发送响应错误:", err)
        }
    }
}
```

UDP客户端实现：
```go
// UDP客户端示例
func udpClient() error {
    // 解析服务器地址
    serverAddr, err := net.ResolveUDPAddr("udp", "localhost:8081")
    if err != nil {
        return err
    }
    
    // 创建本地UDP连接
    conn, err := net.DialUDP("udp", nil, serverAddr)
    if err != nil {
        return err
    }
    defer conn.Close()
    
    // 发送数据
    message := []byte("Hello, UDP Server!")
    _, err = conn.Write(message)
    if err != nil {
        return err
    }
    
    // 接收响应
    buffer := make([]byte, 1024)
    conn.SetReadDeadline(time.Now().Add(5 * time.Second))
    n, _, err := conn.ReadFromUDP(buffer)
    if err != nil {
        return err
    }
    
    fmt.Printf("服务器响应: %s\n", string(buffer[:n]))
    
    return nil
}
```

#### 14.3.2 广播和组播
UDP支持广播和组播功能，用于向多个接收者发送数据：

```go
// UDP广播示例
func udpBroadcast() error {
    // 创建UDP连接
    conn, err := net.DialUDP("udp", nil, &net.UDPAddr{
        IP:   net.IPv4(255, 255, 255, 255), // 广播地址
        Port: 8082,
    })
    if err != nil {
        return err
    }
    defer conn.Close()
    
    // 设置为广播模式
    if err := conn.SetWriteBuffer(65536); err != nil {
        return err
    }
    
    // 发送广播消息
    message := []byte("UDP广播消息")
    _, err = conn.Write(message)
    return err
}

// UDP组播示例
func udpMulticast() error {
    // 组播地址范围: 224.0.0.0 - 239.255.255.255
    addr, err := net.ResolveUDPAddr("udp", "224.0.0.1:8083")
    if err != nil {
        return err
    }
    
    // 创建UDP连接
    conn, err := net.DialUDP("udp", nil, addr)
    if err != nil {
        return err
    }
    defer conn.Close()
    
    // 发送组播消息
    message := []byte("UDP组播消息")
    _, err = conn.Write(message)
    return err
}
```

#### 14.3.3 可靠UDP实现
UDP本身不保证可靠传输，但可以在应用层实现可靠性机制：

```go
// 简化版可靠UDP实现示例
type ReliableUDP struct {
    conn        *net.UDPConn
    maxRetries  int
    timeout     time.Duration
    sequenceNum uint32
    ackChan     map[uint32]chan struct{}
    mu          sync.Mutex
}

func NewReliableUDP(conn *net.UDPConn, maxRetries int, timeout time.Duration) *ReliableUDP {
    rudp := &ReliableUDP{
        conn:       conn,
        maxRetries: maxRetries,
        timeout:    timeout,
        ackChan:    make(map[uint32]chan struct{}),
    }
    
    // 启动ACK处理协程
    go rudp.handleAcks()
    
    return rudp
}

func (r *ReliableUDP) handleAcks() {
    buffer := make([]byte, 1024)
    for {
        n, _, err := r.conn.ReadFromUDP(buffer)
        if err != nil {
            continue
        }
        
        // 解析ACK包
        if n >= 4 {
            seqNum := binary.BigEndian.Uint32(buffer[:4])
            r.mu.Lock()
            ackChan, ok := r.ackChan[seqNum]
            r.mu.Unlock()
            
            if ok {
                // 通知等待此ACK的协程
                select {
                case ackChan <- struct{}{}:
                default:
                }
            }
        }
    }
}

func (r *ReliableUDP) SendReliable(data []byte, addr *net.UDPAddr) error {
    r.mu.Lock()
    seqNum := r.sequenceNum
    r.sequenceNum++
    ackChan := make(chan struct{}, 1)
    r.ackChan[seqNum] = ackChan
    r.mu.Unlock()
    
    // 准备带序列号的数据包
    packet := make([]byte, len(data)+4)
    binary.BigEndian.PutUint32(packet[:4], seqNum)
    copy(packet[4:], data)
    
    // 重试机制
    for i := 0; i < r.maxRetries; i++ {
        // 发送数据
        _, err := r.conn.WriteToUDP(packet, addr)
        if err != nil {
            continue
        }
        
        // 等待ACK或超时
        select {
        case <-ackChan:
            // 收到ACK，传输成功
            r.mu.Lock()
            delete(r.ackChan, seqNum)
            r.mu.Unlock()
            return nil
        case <-time.After(r.timeout):
            // 超时，准备重试
        }
    }
    
    r.mu.Lock()
    delete(r.ackChan, seqNum)
    r.mu.Unlock()
    return fmt.Errorf("发送失败，达到最大重试次数")
}
```

#### 14.3.4 UDP性能优化
UDP性能优化的关键点：

1. **缓冲区大小优化**：
```go
// 设置UDP缓冲区大小
conn.SetReadBuffer(65536)
conn.SetWriteBuffer(65536)
```

2. **批量处理数据包**：聚合小数据包减少系统调用

3. **避免数据拷贝**：使用缓冲池和零拷贝技术
```go
// 使用sync.Pool减少GC压力
var bufferPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1500) // MTU大小
    },
}

// 获取和归还缓冲区
buffer := bufferPool.Get().([]byte)
defer bufferPool.Put(buffer)
```

4. **异步处理**：利用goroutine并行处理多个UDP消息
```go
// 并行处理UDP请求
for {
    n, addr, err := conn.ReadFromUDP(buffer)
    if err != nil {
        continue
    }
    
    // 复制数据以便在goroutine中安全使用
    data := make([]byte, n)
    copy(data, buffer[:n])
    
    // 异步处理请求
    go func(data []byte, addr *net.UDPAddr) {
        // 处理数据
        response := processUDPData(data)
        
        // 发送响应
        conn.WriteToUDP(response, addr)
    }(data, addr)
}
```

### 14.4 HTTP编程

#### 14.4.1 HTTP客户端开发
GO语言的`net/http`包提供了强大而简洁的HTTP客户端功能：

```go
// 基本GET请求
func basicGetRequest() {
    resp, err := http.Get("https://api.example.com/data")
    if err != nil {
        fmt.Println("请求失败:", err)
        return
    }
    defer resp.Body.Close()
    
    // 读取响应体
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        fmt.Println("读取响应失败:", err)
        return
    }
    
    fmt.Println("状态码:", resp.StatusCode)
    fmt.Println("响应体:", string(body))
}

// 自定义HTTP客户端
func customHttpClient() {
    // 创建自定义客户端
    client := &http.Client{
        Timeout: 10 * time.Second,
        Transport: &http.Transport{
            MaxIdleConns:        100,
            MaxIdleConnsPerHost: 20,
            IdleConnTimeout:     30 * time.Second,
            DisableCompression:  true,
        },
    }
    
    // 创建请求
    req, err := http.NewRequest("POST", "https://api.example.com/users", 
        strings.NewReader(`{"name":"张三","age":30}`))
    if err != nil {
        fmt.Println("创建请求失败:", err)
        return
    }
    
    // 设置请求头
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Authorization", "Bearer token123")
    
    // 发送请求
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("请求失败:", err)
        return
    }
    defer resp.Body.Close()
    
    // 处理响应
    // ...
}

// 处理JSON响应
func handleJsonResponse() {
    resp, err := http.Get("https://api.example.com/users")
    if err != nil {
        return
    }
    defer resp.Body.Close()
    
    // 解析JSON响应
    var users []struct {
        ID   int    `json:"id"`
        Name string `json:"name"`
        Age  int    `json:"age"`
    }
    
    if err := json.NewDecoder(resp.Body).Decode(&users); err != nil {
        fmt.Println("JSON解析失败:", err)
        return
    }
    
    // 使用解析后的数据
    for _, user := range users {
        fmt.Printf("用户: %s, 年龄: %d\n", user.Name, user.Age)
    }
}
```

#### 14.4.2 HTTP服务器实现
GO语言的HTTP服务器实现非常简洁：

```go
// 基本HTTP服务器
func basicHttpServer() {
    // 注册处理函数
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "欢迎访问主页!")
    })
    
    http.HandleFunc("/api/users", func(w http.ResponseWriter, r *http.Request) {
        // 设置响应头
        w.Header().Set("Content-Type", "application/json")
        
        // 返回JSON数据
        users := []map[string]interface{}{
            {"id": 1, "name": "张三", "age": 30},
            {"id": 2, "name": "李四", "age": 25},
        }
        
        json.NewEncoder(w).Encode(users)
    })
    
    // 启动服务器
    fmt.Println("HTTP服务器启动在 :8080...")
    err := http.ListenAndServe(":8080", nil)
    if err != nil {
        fmt.Println("服务器启动失败:", err)
    }
}

// 自定义HTTP服务器
func customHttpServer() {
    // 创建路由器
    mux := http.NewServeMux()
    
    // 注册处理函数
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "欢迎访问主页!")
    })
    
    // 创建自定义服务器
    server := &http.Server{
        Addr:         ":8080",
        Handler:      mux,
        ReadTimeout:  10 * time.Second,
        WriteTimeout: 10 * time.Second,
        IdleTimeout:  120 * time.Second,
    }
    
    // 启动服务器
    fmt.Println("自定义HTTP服务器启动在 :8080...")
    err := server.ListenAndServe()
    if err != nil {
        fmt.Println("服务器启动失败:", err)
    }
}

// 处理文件上传
func handleFileUpload(w http.ResponseWriter, r *http.Request) {
    // 限制请求体大小
    r.ParseMultipartForm(10 << 20) // 10MB
    
    // 获取上传的文件
    file, handler, err := r.FormFile("uploadFile")
    if err != nil {
        fmt.Println("获取文件失败:", err)
        http.Error(w, "获取文件失败", http.StatusBadRequest)
        return
    }
    defer file.Close()
    
    // 创建目标文件
    dst, err := os.Create("uploads/" + handler.Filename)
    if err != nil {
        http.Error(w, "保存文件失败", http.StatusInternalServerError)
        return
    }
    defer dst.Close()
    
    // 复制文件内容
    if _, err := io.Copy(dst, file); err != nil {
        http.Error(w, "复制文件失败", http.StatusInternalServerError)
        return
    }
    
    fmt.Fprintf(w, "文件上传成功: %s, 大小: %d bytes", 
        handler.Filename, handler.Size)
}
```

#### 14.4.3 中间件设计模式
中间件是一种强大的设计模式，用于处理横切关注点（如日志、认证、CORS等）：

```go
// 中间件类型
type Middleware func(http.Handler) http.Handler

// 日志中间件
func LoggingMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        
        // 调用下一个处理器
        next.ServeHTTP(w, r)
        
        // 记录请求日志
        fmt.Printf(
            "%s %s %s %s\n",
            r.Method,
            r.RequestURI,
            r.RemoteAddr,
            time.Since(start),
        )
    })
}

// 认证中间件
func AuthMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 获取并验证token
        token := r.Header.Get("Authorization")
        if !validateToken(token) {
            http.Error(w, "未授权访问", http.StatusUnauthorized)
            return
        }
        
        // 认证通过，调用下一个处理器
        next.ServeHTTP(w, r)
    })
}

// 验证token的函数（示例）
func validateToken(token string) bool {
    // 实际应用中需要实现真正的token验证逻辑
    return token != ""
}

// 使用中间件链
func chainMiddleware(h http.Handler, middlewares ...Middleware) http.Handler {
    for _, middleware := range middlewares {
        h = middleware(h)
    }
    return h
}

// 应用中间件
func useMiddleware() {
    // 创建处理器
    handler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        fmt.Fprintf(w, "受保护的资源")
    })
    
    // 应用中间件链
    chain := chainMiddleware(handler, LoggingMiddleware, AuthMiddleware)
    
    // 注册处理器
    http.Handle("/protected", chain)
    
    // 启动服务器
    http.ListenAndServe(":8080", nil)
}
```

#### 14.4.4 RESTful API开发
RESTful API是一种常用的Web API设计风格，强调使用HTTP方法表达语义：

```go
// 用户结构体
type User struct {
    ID   int    `json:"id"`
    Name string `json:"name"`
    Age  int    `json:"age"`
}

// 用户数据存储（示例用内存存储）
var users = []User{
    {ID: 1, Name: "张三", Age: 30},
    {ID: 2, Name: "李四", Age: 25},
}

// RESTful API处理器
func userHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    
    // 提取路径参数（简化实现）
    parts := strings.Split(r.URL.Path, "/")
    idStr := ""
    if len(parts) > 2 {
        idStr = parts[2]
    }
    
    switch r.Method {
    case "GET":
        // 获取所有用户或单个用户
        if idStr == "" {
            // 返回所有用户
            json.NewEncoder(w).Encode(users)
        } else {
            // 获取特定用户
            id, err := strconv.Atoi(idStr)
            if err != nil {
                http.Error(w, "无效的ID", http.StatusBadRequest)
                return
            }
            
            for _, user := range users {
                if user.ID == id {
                    json.NewEncoder(w).Encode(user)
                    return
                }
            }
            
            http.Error(w, "用户不存在", http.StatusNotFound)
        }
        
    case "POST":
        // 创建新用户
        var newUser User
        if err := json.NewDecoder(r.Body).Decode(&newUser); err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }
        
        // 分配新ID（简化实现）
        newUser.ID = len(users) + 1
        users = append(users, newUser)
        
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(newUser)
        
    case "PUT":
        // 更新用户
        id, err := strconv.Atoi(idStr)
        if err != nil {
            http.Error(w, "无效的ID", http.StatusBadRequest)
            return
        }
        
        var updatedUser User
        if err := json.NewDecoder(r.Body).Decode(&updatedUser); err != nil {
            http.Error(w, err.Error(), http.StatusBadRequest)
            return
        }
        
        for i, user := range users {
            if user.ID == id {
                updatedUser.ID = id // 确保ID不变
                users[i] = updatedUser
                json.NewEncoder(w).Encode(updatedUser)
                return
            }
        }
        
        http.Error(w, "用户不存在", http.StatusNotFound)
        
    case "DELETE":
        // 删除用户
        id, err := strconv.Atoi(idStr)
        if err != nil {
            http.Error(w, "无效的ID", http.StatusBadRequest)
            return
        }
        
        for i, user := range users {
            if user.ID == id {
                // 从切片中删除
                users = append(users[:i], users[i+1:]...)
                w.WriteHeader(http.StatusNoContent)
                return
            }
        }
        
        http.Error(w, "用户不存在", http.StatusNotFound)
        
    default:
        http.Error(w, "方法不允许", http.StatusMethodNotAllowed)
    }
}

// 启动RESTful API服务器
func startRESTfulServer() {
    http.HandleFunc("/api/users/", userHandler)
    http.HandleFunc("/api/users", userHandler)
    
    fmt.Println("RESTful API服务器启动在 :8080...")
    http.ListenAndServe(":8080", nil)
}
```

### 14.5 WebSocket编程

#### 14.5.1 WebSocket协议实现
WebSocket是一种提供全双工通信的协议，通常使用`gorilla/websocket`包实现：

```go
// 导入必要的包
import (
    "github.com/gorilla/websocket"
    "net/http"
    "time"
)

// WebSocket升级器
var upgrader = websocket.Upgrader{
    ReadBufferSize:  1024,
    WriteBufferSize: 1024,
    // 允许所有CORS请求
    CheckOrigin: func(r *http.Request) bool {
        return true
    },
}

// WebSocket连接处理函数
func handleWebSocket(w http.ResponseWriter, r *http.Request) {
    // 升级HTTP连接为WebSocket
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        fmt.Println("WebSocket升级失败:", err)
        return
    }
    defer conn.Close()
    
    // 设置连接参数
    conn.SetReadLimit(512) // 限制消息大小
    conn.SetReadDeadline(time.Now().Add(60 * time.Second))
    conn.SetPongHandler(func(string) error {
        conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        return nil
    })
    
    // 消息处理循环
    for {
        // 读取消息
        messageType, message, err := conn.ReadMessage()
        if err != nil {
            if websocket.IsUnexpectedCloseError(err, 
                websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
                fmt.Println("WebSocket错误:", err)
            }
            break
        }
        
        // 处理消息
        fmt.Printf("收到消息: %s\n", message)
        
        // 回复消息
        response := []byte("服务器已收到: " + string(message))
        if err := conn.WriteMessage(messageType, response); err != nil {
            fmt.Println("写入错误:", err)
            break
        }
    }
}

// 启动WebSocket服务器
func startWebSocketServer() {
    http.HandleFunc("/ws", handleWebSocket)
    
    // 提供一个简单的客户端页面
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        html := `
        <!DOCTYPE html>
        <html>
        <head>
            <title>WebSocket测试</title>
            <script>
                let socket;
                
                function connect() {
                    socket = new WebSocket("ws://" + window.location.host + "/ws");
                    
                    socket.onopen = function(e) {
                        console.log("连接已建立");
                    };
                    
                    socket.onmessage = function(event) {
                        document.getElementById("messages").innerHTML += 
                            "<p>" + event.data + "</p>";
                    };
                    
                    socket.onclose = function(event) {
                        console.log("连接已关闭");
                    };
                }
                
                function sendMessage() {
                    let message = document.getElementById("message").value;
                    socket.send(message);
                    document.getElementById("message").value = "";
                }
                
                window.onload = connect;
            </script>
        </head>
        <body>
            <h1>WebSocket测试</h1>
            <input type="text" id="message" placeholder="输入消息">
            <button onclick="sendMessage()">发送</button>
            <div id="messages"></div>
        </body>
        </html>
        `
        fmt.Fprintf(w, html)
    })
    
    fmt.Println("WebSocket服务器启动在 :8080...")
    http.ListenAndServe(":8080", nil)
}
```

#### 14.5.2 实时通信应用
WebSocket适合构建实时通信应用，如聊天系统：

```go
// 聊天室实现
type ChatRoom struct {
    clients    map[*websocket.Conn]bool
    broadcast  chan []byte
    register   chan *websocket.Conn
    unregister chan *websocket.Conn
    mutex      sync.Mutex
}

// 创建新的聊天室
func NewChatRoom() *ChatRoom {
    return &ChatRoom{
        clients:    make(map[*websocket.Conn]bool),
        broadcast:  make(chan []byte),
        register:   make(chan *websocket.Conn),
        unregister: make(chan *websocket.Conn),
    }
}

// 运行聊天室
func (cr *ChatRoom) Run() {
    for {
        select {
        case client := <-cr.register:
            // 注册新客户端
            cr.mutex.Lock()
            cr.clients[client] = true
            cr.mutex.Unlock()
            
        case client := <-cr.unregister:
            // 注销客户端
            cr.mutex.Lock()
            if _, ok := cr.clients[client]; ok {
                delete(cr.clients, client)
                client.Close()
            }
            cr.mutex.Unlock()
            
        case message := <-cr.broadcast:
            // 广播消息给所有客户端
            cr.mutex.Lock()
            for client := range cr.clients {
                err := client.WriteMessage(websocket.TextMessage, message)
                if err != nil {
                    client.Close()
                    delete(cr.clients, client)
                }
            }
            cr.mutex.Unlock()
        }
    }
}

// 处理WebSocket连接
func (cr *ChatRoom) HandleConnection(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        fmt.Println("升级连接失败:", err)
        return
    }
    
    // 注册新客户端
    cr.register <- conn
    
    // 在连接关闭时注销客户端
    defer func() {
        cr.unregister <- conn
    }()
    
    // 消息读取循环
    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            break
        }
        
        // 广播消息
        cr.broadcast <- message
    }
}

// 启动聊天服务器
func startChatServer() {
    chatRoom := NewChatRoom()
    go chatRoom.Run()
    
    http.HandleFunc("/ws", chatRoom.HandleConnection)
    
    // 提供聊天页面
    http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "chat.html")
    })
    
    fmt.Println("聊天服务器启动在 :8080...")
    http.ListenAndServe(":8080", nil)
}
```

#### 14.5.3 消息推送系统
WebSocket可用于实现服务器到客户端的实时消息推送：

```go
// 消息推送系统
type PushSystem struct {
    // 按主题组织的客户端映射
    topics map[string]map[*websocket.Conn]bool
    mutex  sync.RWMutex
}

// 创建新的推送系统
func NewPushSystem() *PushSystem {
    return &PushSystem{
        topics: make(map[string]map[*websocket.Conn]bool),
    }
}

// 订阅主题
func (ps *PushSystem) Subscribe(conn *websocket.Conn, topic string) {
    ps.mutex.Lock()
    defer ps.mutex.Unlock()
    
    // 确保主题存在
    if _, ok := ps.topics[topic]; !ok {
        ps.topics[topic] = make(map[*websocket.Conn]bool)
    }
    
    // 添加连接到主题
    ps.topics[topic][conn] = true
}

// 取消订阅
func (ps *PushSystem) Unsubscribe(conn *websocket.Conn, topic string) {
    ps.mutex.Lock()
    defer ps.mutex.Unlock()
    
    if clients, ok := ps.topics[topic]; ok {
        delete(clients, conn)
        
        // 如果主题没有订阅者，清理主题
        if len(clients) == 0 {
            delete(ps.topics, topic)
        }
    }
}

// 发布消息到主题
func (ps *PushSystem) Publish(topic string, message []byte) {
    ps.mutex.RLock()
    clients, ok := ps.topics[topic]
    ps.mutex.RUnlock()
    
    if !ok {
        return // 主题不存在
    }
    
    // 向所有订阅者发送消息
    for conn := range clients {
        err := conn.WriteMessage(websocket.TextMessage, message)
        if err != nil {
            // 连接失败，移除订阅
            ps.mutex.Lock()
            delete(clients, conn)
            ps.mutex.Unlock()
            
            conn.Close()
        }
    }
}

// 处理WebSocket连接
func (ps *PushSystem) HandleConnection(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        fmt.Println("升级连接失败:", err)
        return
    }
    
    // 获取要订阅的主题
    topic := r.URL.Query().Get("topic")
    if topic == "" {
        conn.Close()
        return
    }
    
    // 订阅主题
    ps.Subscribe(conn, topic)
    
    // 在连接关闭时取消订阅
    defer func() {
        ps.Unsubscribe(conn, topic)
        conn.Close()
    }()
    
    // 保持连接活跃的消息读取循环
    for {
        if _, _, err := conn.ReadMessage(); err != nil {
            break
        }
    }
}

// 模拟消息发布
func simulateMessagePublishing(ps *PushSystem) {
    topics := []string{"news", "sports", "tech"}
    
    for {
        for _, topic := range topics {
            message := fmt.Sprintf("主题 %s 的新消息: %s", 
                topic, time.Now().Format("15:04:05"))
            
            ps.Publish(topic, []byte(message))
        }
        
        time.Sleep(5 * time.Second)
    }
}

// 启动推送服务器
func startPushServer() {
    pushSystem := NewPushSystem()
    
    // 启动模拟发布
    go simulateMessagePublishing(pushSystem)
    
    // 处理WebSocket连接
    http.HandleFunc("/subscribe", pushSystem.HandleConnection)
    
    fmt.Println("推送服务器启动在 :8080...")
    http.ListenAndServe(":8080", nil)
}
```

#### 14.5.4 连接管理和心跳
WebSocket连接需要有效管理，包括心跳机制：

```go
// WebSocket连接管理器
type ConnectionManager struct {
    connections map[string]*websocket.Conn // 使用用户ID或其他唯一标识作为键
    mutex       sync.RWMutex
    done        chan struct{}
}

// 创建新的连接管理器
func NewConnectionManager() *ConnectionManager {
    cm := &ConnectionManager{
        connections: make(map[string]*websocket.Conn),
        done:        make(chan struct{}),
    }
    
    // 启动心跳检测
    go cm.heartbeatChecker()
    
    return cm
}

// 添加连接
func (cm *ConnectionManager) Add(id string, conn *websocket.Conn) {
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    // 如果已存在，先关闭旧连接
    if oldConn, exists := cm.connections[id]; exists {
        oldConn.Close()
    }
    
    // 设置心跳处理函数
    conn.SetPongHandler(func(string) error {
        conn.SetReadDeadline(time.Now().Add(60 * time.Second))
        return nil
    })
    
    cm.connections[id] = conn
}

// 移除连接
func (cm *ConnectionManager) Remove(id string) {
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    if conn, exists := cm.connections[id]; exists {
        conn.Close()
        delete(cm.connections, id)
    }
}

// 获取连接
func (cm *ConnectionManager) Get(id string) (*websocket.Conn, bool) {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    conn, exists := cm.connections[id]
    return conn, exists
}

// 心跳检测器
func (cm *ConnectionManager) heartbeatChecker() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            cm.sendHeartbeats()
        case <-cm.done:
            return
        }
    }
}

// 发送心跳
func (cm *ConnectionManager) sendHeartbeats() {
    cm.mutex.RLock()
    defer cm.mutex.RUnlock()
    
    for id, conn := range cm.connections {
        if err := conn.WriteControl(
            websocket.PingMessage, 
            []byte{}, 
            time.Now().Add(5*time.Second),
        ); err != nil {
            // 心跳失败，连接可能已断开
            conn.Close()
            
            // 因为已有读锁，不能在此删除，标记为待删除
            go cm.Remove(id)
        }
    }
}

// 关闭连接管理器
func (cm *ConnectionManager) Close() {
    close(cm.done)
    
    cm.mutex.Lock()
    defer cm.mutex.Unlock()
    
    for id, conn := range cm.connections {
        conn.Close()
        delete(cm.connections, id)
    }
}

// WebSocket处理函数示例
func (cm *ConnectionManager) HandleWebSocket(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        fmt.Println("升级连接失败:", err)
        return
    }
    
    // 获取用户ID（从请求中）
    userID := r.URL.Query().Get("user_id")
    if userID == "" {
        conn.Close()
        return
    }
    
    // 添加到连接管理器
    cm.Add(userID, conn)
    
    // 处理连接关闭
    defer func() {
        cm.Remove(userID)
    }()
    
    // 消息处理循环
    for {
        _, message, err := conn.ReadMessage()
        if err != nil {
            break
        }
        
        // 处理消息
        fmt.Printf("用户 %s 发送消息: %s\n", userID, message)
    }
}
```

### 14.6 网络安全
- TLS/SSL加密通信
- 证书管理
- 身份认证和授权
- 防护常见网络攻击

### 14.7 高性能网络编程
- IO多路复用
- 事件驱动模型
- 连接复用技术
- 网络性能调优

### 14.8 网络工具和调试

#### 14.8.1 网络抓包分析
网络抓包是排查网络问题的强大工具：

```go
// 使用GO实现简单的数据包捕获
import (
    "fmt"
    "github.com/google/gopacket"
    "github.com/google/gopacket/pcap"
    "log"
    "time"
)

func capturePackets() {
    // 获取网络接口列表
    devices, err := pcap.FindAllDevs()
    if err != nil {
        log.Fatal(err)
    }
    
    // 打印可用设备
    fmt.Println("可用设备:")
    for _, device := range devices {
        fmt.Printf("名称: %s\n", device.Name)
        fmt.Printf("  描述: %s\n", device.Description)
        fmt.Println("  设备地址:")
        for _, address := range device.Addresses {
            fmt.Printf("    IP: %s, 掩码: %s\n", 
                address.IP, address.Netmask)
        }
    }
    
    // 选择一个设备进行捕获
    deviceName := devices[0].Name // 或根据需要选择
    
    // 打开设备
    handle, err := pcap.OpenLive(deviceName, 1600, true, pcap.BlockForever)
    if err != nil {
        log.Fatal(err)
    }
    defer handle.Close()
    
    // 设置过滤器（可选）
    if err := handle.SetBPFFilter("tcp and port 80"); err != nil {
        log.Fatal(err)
    }
    
    // 创建数据包源
    packetSource := gopacket.NewPacketSource(handle, handle.LinkType())
    
    // 设置捕获超时
    timeout := time.After(30 * time.Second)
    
    // 捕获数据包
    fmt.Println("开始捕获数据包...")
    for {
        select {
        case packet := <-packetSource.Packets():
            // 分析数据包
            fmt.Println("捕获到数据包:")
            fmt.Printf("  时间戳: %v\n", packet.Metadata().Timestamp)
            fmt.Printf("  长度: %d 字节\n", packet.Metadata().Length)
            
            // 如果包含TCP层
            if tcpLayer := packet.Layer(gopacket.LayerTypeTCP); tcpLayer != nil {
                tcp, _ := tcpLayer.(*gopacket.TCP)
                fmt.Printf("  TCP 源端口: %d, 目标端口: %d\n", 
                    tcp.SrcPort, tcp.DstPort)
            }
            
            // 如果包含IP层
            if ipLayer := packet.Layer(gopacket.LayerTypeIPv4); ipLayer != nil {
                ip, _ := ipLayer.(*gopacket.IPv4)
                fmt.Printf("  IP 源地址: %s, 目标地址: %s\n", 
                    ip.SrcIP, ip.DstIP)
            }
            
        case <-timeout:
            fmt.Println("捕获超时")
            return
        }
    }
}
```

#### 14.8.2 性能监控
监控网络应用性能的工具和方法：

```go
// 网络性能监控系统
type NetworkMonitor struct {
    stats      map[string]*ConnectionStats
    mu         sync.RWMutex
    sampleRate time.Duration
    stopChan   chan struct{}
}

// 连接统计
type ConnectionStats struct {
    BytesIn       int64
    BytesOut      int64
    PacketsIn     int64
    PacketsOut    int64
    Errors        int64
    LastActivity  time.Time
    ResponseTimes []time.Duration
}

// 创建网络监控器
func NewNetworkMonitor(sampleRate time.Duration) *NetworkMonitor {
    return &NetworkMonitor{
        stats:      make(map[string]*ConnectionStats),
        sampleRate: sampleRate,
        stopChan:   make(chan struct{}),
    }
}

// 记录传入流量
func (nm *NetworkMonitor) RecordInbound(remoteAddr string, bytes int) {
    nm.mu.Lock()
    defer nm.mu.Unlock()
    
    stats, ok := nm.stats[remoteAddr]
    if !ok {
        stats = &ConnectionStats{
            LastActivity: time.Now(),
        }
        nm.stats[remoteAddr] = stats
    }
    
    stats.BytesIn += int64(bytes)
    stats.PacketsIn++
    stats.LastActivity = time.Now()
}

// 记录传出流量
func (nm *NetworkMonitor) RecordOutbound(remoteAddr string, bytes int) {
    nm.mu.Lock()
    defer nm.mu.Unlock()
    
    stats, ok := nm.stats[remoteAddr]
    if !ok {
        stats = &ConnectionStats{
            LastActivity: time.Now(),
        }
        nm.stats[remoteAddr] = stats
    }
    
    stats.BytesOut += int64(bytes)
    stats.PacketsOut++
    stats.LastActivity = time.Now()
}

// 记录响应时间
func (nm *NetworkMonitor) RecordResponseTime(remoteAddr string, duration time.Duration) {
    nm.mu.Lock()
    defer nm.mu.Unlock()
    
    stats, ok := nm.stats[remoteAddr]
    if !ok {
        stats = &ConnectionStats{
            LastActivity: time.Now(),
        }
        nm.stats[remoteAddr] = stats
    }
    
    stats.ResponseTimes = append(stats.ResponseTimes, duration)
    // 只保留最近100个样本
    if len(stats.ResponseTimes) > 100 {
        stats.ResponseTimes = stats.ResponseTimes[1:]
    }
}

// 启动监控
func (nm *NetworkMonitor) Start() {
    go func() {
        ticker := time.NewTicker(nm.sampleRate)
        defer ticker.Stop()
        
        for {
            select {
            case <-ticker.C:
                nm.generateReport()
            case <-nm.stopChan:
                return
            }
        }
    }()
}

// 停止监控
func (nm *NetworkMonitor) Stop() {
    close(nm.stopChan)
}

// 生成报告
func (nm *NetworkMonitor) generateReport() {
    nm.mu.RLock()
    defer nm.mu.RUnlock()
    
    now := time.Now()
    fmt.Println("=== 网络监控报告 ===")
    fmt.Printf("时间: %s\n", now.Format("2006-01-02 15:04:05"))
    fmt.Printf("活跃连接数: %d\n", len(nm.stats))
    
    var totalIn, totalOut int64
    var inactiveCount int
    
    for addr, stats := range nm.stats {
        totalIn += stats.BytesIn
        totalOut += stats.BytesOut
        
        // 检查不活跃连接
        if now.Sub(stats.LastActivity) > 5*time.Minute {
            inactiveCount++
        }
        
        // 计算平均响应时间
        var avgResponse time.Duration
        if len(stats.ResponseTimes) > 0 {
            var total time.Duration
            for _, rt := range stats.ResponseTimes {
                total += rt
            }
            avgResponse = total / time.Duration(len(stats.ResponseTimes))
        }
        
        fmt.Printf("连接 %s: 入流量=%d字节, 出流量=%d字节, 平均响应时间=%v\n", 
            addr, stats.BytesIn, stats.BytesOut, avgResponse)
    }
    
    fmt.Printf("总入流量: %d字节\n", totalIn)
    fmt.Printf("总出流量: %d字节\n", totalOut)
    fmt.Printf("不活跃连接数: %d\n", inactiveCount)
    fmt.Println("=====================")
}

// 获取当前统计信息
func (nm *NetworkMonitor) GetStats() map[string]*ConnectionStats {
    nm.mu.RLock()
    defer nm.mu.RUnlock()
    
    // 创建副本以避免竞态条件
    result := make(map[string]*ConnectionStats)
    for k, v := range nm.stats {
        statsCopy := *v
        result[k] = &statsCopy
    }
    
    return result
}
```

#### 14.8.3 故障诊断
网络应用故障诊断工具：

```go
// 网络故障诊断工具
type NetworkDiagnostic struct {
    targetHost string
    targetPort int
    timeout    time.Duration
}

// 创建诊断工具
func NewNetworkDiagnostic(host string, port int, timeout time.Duration) *NetworkDiagnostic {
    return &NetworkDiagnostic{
        targetHost: host,
        targetPort: port,
        timeout:    timeout,
    }
}

// 运行完整诊断
func (nd *NetworkDiagnostic) RunDiagnostics() {
    fmt.Printf("开始对 %s:%d 进行网络诊断\n", nd.targetHost, nd.targetPort)
    
    // DNS解析测试
    nd.checkDNS()
    
    // 连接测试
    nd.checkConnection()
    
    // 路由跟踪
    nd.traceRoute()
    
    // HTTP测试（如果是Web服务）
    nd.checkHTTP()
    
    fmt.Println("诊断完成")
}

// DNS解析测试
func (nd *NetworkDiagnostic) checkDNS() {
    fmt.Println("DNS解析测试:")
    
    ips, err := net.LookupIP(nd.targetHost)
    if err != nil {
        fmt.Printf("  DNS解析失败: %v\n", err)
        return
    }
    
    fmt.Printf("  解析成功! IP地址: ")
    for i, ip := range ips {
        if i > 0 {
            fmt.Print(", ")
        }
        fmt.Print(ip)
    }
    fmt.Println()
}

// 连接测试
func (nd *NetworkDiagnostic) checkConnection() {
    fmt.Println("连接测试:")
    
    address := fmt.Sprintf("%s:%d", nd.targetHost, nd.targetPort)
    conn, err := net.DialTimeout("tcp", address, nd.timeout)
    if err != nil {
        fmt.Printf("  连接失败: %v\n", err)
        return
    }
    defer conn.Close()
    
    fmt.Printf("  连接成功! 本地地址: %v, 远程地址: %v\n", 
        conn.LocalAddr(), conn.RemoteAddr())
}

// 路由跟踪
func (nd *NetworkDiagnostic) traceRoute() {
    fmt.Println("路由跟踪:")
    fmt.Println("  注意: 完整路由跟踪需要系统权限，这里仅展示概念")
    
    // 实际实现通常需要调用系统命令或使用原始套接字
    // 这里简化展示
    fmt.Println("  1. 本地网关")
    fmt.Println("  2. ISP路由器")
    fmt.Printf("  3. %s\n", nd.targetHost)
}

// HTTP测试
func (nd *NetworkDiagnostic) checkHTTP() {
    fmt.Println("HTTP测试:")
    
    url := fmt.Sprintf("http://%s:%d", nd.targetHost, nd.targetPort)
    client := &http.Client{
        Timeout: nd.timeout,
    }
    
    start := time.Now()
    resp, err := client.Get(url)
    if err != nil {
        fmt.Printf("  HTTP请求失败: %v\n", err)
        return
    }
    defer resp.Body.Close()
    
    elapsed := time.Since(start)
    
    // 读取部分响应体
    body := make([]byte, 1024)
    n, _ := resp.Body.Read(body)
    
    fmt.Printf("  HTTP请求成功! 状态码: %d, 响应时间: %v\n", 
        resp.StatusCode, elapsed)
    fmt.Printf("  响应头: %v\n", resp.Header)
    fmt.Printf("  响应体片段: %s\n", body[:n])
}

// 检查特定端口是否开放
func (nd *NetworkDiagnostic) checkPort(port int) bool {
    address := fmt.Sprintf("%s:%d", nd.targetHost, port)
    conn, err := net.DialTimeout("tcp", address, 2*time.Second)
    if err != nil {
        return false
    }
    
    conn.Close()
    return true
}

// 端口扫描
func (nd *NetworkDiagnostic) scanPorts(startPort, endPort int) map[int]bool {
    results := make(map[int]bool)
    var wg sync.WaitGroup
    var mu sync.Mutex
    
    for port := startPort; port <= endPort; port++ {
        wg.Add(1)
        go func(p int) {
            defer wg.Done()
            
            isOpen := nd.checkPort(p)
            if isOpen {
                mu.Lock()
                results[p] = true
                mu.Unlock()
                
                fmt.Printf("  端口 %d 开放\n", p)
            }
        }(port)
    }
    
    wg.Wait()
    return results
}
```

#### 14.8.4 压力测试
网络应用压力测试工具：

```go
// 压力测试工具
type LoadTester struct {
    targetURL     string
    concurrency   int
    requestCount  int
    requestMethod string
    requestBody   []byte
    headers       map[string]string
    results       []TestResult
    resultChan    chan TestResult
    wg            sync.WaitGroup
    client        *http.Client
}

// 测试结果
type TestResult struct {
    Duration   time.Duration
    StatusCode int
    Error      error
    BytesRead  int
}

// 创建压力测试工具
func NewLoadTester(url string, concurrency, requestCount int) *LoadTester {
    return &LoadTester{
        targetURL:     url,
        concurrency:   concurrency,
        requestCount:  requestCount,
        requestMethod: "GET",
        headers:       make(map[string]string),
        resultChan:    make(chan TestResult, requestCount),
        client: &http.Client{
            Timeout: 30 * time.Second,
            Transport: &http.Transport{
                MaxIdleConnsPerHost: concurrency,
            },
        },
    }
}

// 设置请求方法
func (lt *LoadTester) SetMethod(method string) {
    lt.requestMethod = method
}

// 设置请求体
func (lt *LoadTester) SetRequestBody(body []byte) {
    lt.requestBody = body
}

// 添加请求头
func (lt *LoadTester) AddHeader(key, value string) {
    lt.headers[key] = value
}

// 执行测试
func (lt *LoadTester) Run() []TestResult {
    fmt.Printf("开始压力测试: %s\n", lt.targetURL)
    fmt.Printf("并发: %d, 总请求数: %d\n", lt.concurrency, lt.requestCount)
    
    // 启动工作协程
    for i := 0; i < lt.concurrency; i++ {
        lt.wg.Add(1)
        go lt.worker()
    }
    
    // 收集结果
    go func() {
        lt.wg.Wait()
        close(lt.resultChan)
    }()
    
    // 收集所有结果
    for result := range lt.resultChan {
        lt.results = append(lt.results, result)
    }
    
    // 分析并显示结果
    lt.analyzeResults()
    
    return lt.results
}

// 工作协程
func (lt *LoadTester) worker() {
    defer lt.wg.Done()
    
    requestsPerWorker := lt.requestCount / lt.concurrency
    remainingRequests := lt.requestCount % lt.concurrency
    
    // 均匀分配请求
    myRequestCount := requestsPerWorker
    if remainingRequests > 0 {
        myRequestCount++
        remainingRequests--
    }
    
    for i := 0; i < myRequestCount; i++ {
        result := lt.makeRequest()
        lt.resultChan <- result
    }
}

// 发送单个请求
func (lt *LoadTester) makeRequest() TestResult {
    // 创建请求
    var reqBody io.Reader
    if lt.requestBody != nil {
        reqBody = bytes.NewReader(lt.requestBody)
    }
    
    req, err := http.NewRequest(lt.requestMethod, lt.targetURL, reqBody)
    if err != nil {
        return TestResult{Error: err}
    }
    
    // 设置请求头
    for key, value := range lt.headers {
        req.Header.Set(key, value)
    }
    
    // 发送请求并计时
    start := time.Now()
    resp, err := lt.client.Do(req)
    if err != nil {
        return TestResult{
            Duration: time.Since(start),
            Error:    err,
        }
    }
    defer resp.Body.Close()
    
    // 读取响应体（以测量完整响应时间）
    body, err := io.ReadAll(resp.Body)
    duration := time.Since(start)
    
    if err != nil {
        return TestResult{
            Duration:   duration,
            StatusCode: resp.StatusCode,
            Error:      err,
        }
    }
    
    return TestResult{
        Duration:   duration,
        StatusCode: resp.StatusCode,
        BytesRead:  len(body),
    }
}

// 分析测试结果
func (lt *LoadTester) analyzeResults() {
    if len(lt.results) == 0 {
        fmt.Println("没有收集到结果")
        return
    }
    
    // 计算统计数据
    var totalDuration time.Duration
    var minDuration = lt.results[0].Duration
    var maxDuration time.Duration
    var errorCount int
    var totalBytes int
    
    statusCounts := make(map[int]int)
    
    for _, result := range lt.results {
        totalDuration += result.Duration
        
        if result.Duration < minDuration {
            minDuration = result.Duration
        }
        
        if result.Duration > maxDuration {
            maxDuration = result.Duration
        }
        
        if result.Error != nil {
            errorCount++
        } else {
            statusCounts[result.StatusCode]++
            totalBytes += result.BytesRead
        }
    }
    
    avgDuration := totalDuration / time.Duration(len(lt.results))
    
    // 输出结果
    fmt.Println("===== 测试结果 =====")
    fmt.Printf("完成请求数: %d\n", len(lt.results))
    fmt.Printf("平均响应时间: %v\n", avgDuration)
    fmt.Printf("最小响应时间: %v\n", minDuration)
    fmt.Printf("最大响应时间: %v\n", maxDuration)
    fmt.Printf("错误数: %d (%.2f%%)\n", 
        errorCount, float64(errorCount)*100/float64(len(lt.results)))
    fmt.Printf("总传输数据: %.2f MB\n", float64(totalBytes)/(1024*1024))
    
    fmt.Println("状态码分布:")
    for code, count := range statusCounts {
        fmt.Printf("  %d: %d (%.2f%%)\n", 
            code, count, float64(count)*100/float64(len(lt.results)))
    }
    
    // 计算每秒请求数
    totalTime := maxDuration
    if totalTime < time.Second {
        totalTime = time.Second
    }
    rps := float64(len(lt.results)) / totalTime.Seconds()
    fmt.Printf("每秒请求数 (RPS): %.2f\n", rps)
}
```

## 面试要点

### TCP和UDP的区别和使用场景
- **TCP特点**：
  - 面向连接：通信前需要建立连接（三次握手）
  - 可靠传输：有确认、重传机制
  - 有序传输：保证数据按发送顺序到达
  - 流量控制：通过窗口大小控制发送速率
  - 拥塞控制：根据网络状况调整发送速率
  - 开销较大：头部20字节起
  
- **UDP特点**：
  - 无连接：发送数据前不需要建立连接
  - 不可靠传输：无确认、重传机制
  - 无序传输：不保证数据到达顺序
  - 无流量控制、拥塞控制
  - 开销小：头部8字节
  - 支持广播和多播

- **TCP适用场景**：
  - 文件传输（FTP）
  - Web应用（HTTP/HTTPS）
  - 邮件传输（SMTP）
  - 远程登录（SSH）
  - 数据库通信

- **UDP适用场景**：
  - 音视频流媒体
  - 实时游戏
  - DNS查询
  - SNMP网络管理
  - IoT设备通信

### HTTP协议的实现细节
- **HTTP请求组成**：
  - 请求行（方法、URI、HTTP版本）
  - 请求头
  - 空行
  - 请求体（可选）

- **HTTP响应组成**：
  - 状态行（HTTP版本、状态码、状态消息）
  - 响应头
  - 空行
  - 响应体

- **HTTP方法**：
  - GET：获取资源
  - POST：创建资源
  - PUT：更新资源
  - DELETE：删除资源
  - HEAD：获取响应头
  - OPTIONS：获取支持的方法
  - PATCH：部分更新资源

- **状态码分类**：
  - 1xx：信息响应
  - 2xx：成功响应
  - 3xx：重定向
  - 4xx：客户端错误
  - 5xx：服务器错误

- **HTTP/1.1 vs HTTP/2**：
  - HTTP/2支持多路复用
  - HTTP/2支持服务器推送
  - HTTP/2使用二进制帧
  - HTTP/2头部压缩

### 网络编程的并发处理
- **GO并发模型**：
  - 轻量级goroutine（2KB初始栈）
  - 非阻塞IO结合goroutine调度
  - channel通信
  - 调度器自动管理goroutine

- **并发模式**：
  - worker池模式
  - pipeline模式
  - fan-out/fan-in模式
  - 发布-订阅模式
  - 超时控制模式

- **并发控制**：
  - 互斥锁（sync.Mutex）
  - 读写锁（sync.RWMutex）
  - 条件变量（sync.Cond）
  - 原子操作（atomic包）
  - WaitGroup等待组
  - 信号量模式（使用channel实现）

### 网络安全的最佳实践
- **传输层安全**：
  - 使用TLS 1.2+加密通信
  - 定期更新证书
  - 合理配置密码套件
  - 实施HSTS

- **认证授权**：
  - 使用JWT等token机制
  - 实施多因素认证
  - 权限最小化原则
  - 使用OAuth2/OpenID Connect

- **常见攻击防护**：
  - XSS：输入验证、输出编码、CSP
  - CSRF：使用CSRF令牌、SameSite Cookie
  - SQL注入：参数化查询、ORM
  - DDoS：速率限制、CDN、负载均衡

- **数据保护**：
  - 敏感数据加密存储
  - 传输数据加密
  - 数据最小化收集
  - 定期安全审计

### 高并发网络服务的设计
- **架构模式**：
  - 微服务架构
  - 无状态设计
  - 分层架构
  - 事件驱动架构

- **扩展策略**：
  - 水平扩展（增加实例）
  - 垂直扩展（增加资源）
  - 功能分解
  - 数据分片

- **服务治理**：
  - 服务发现
  - 负载均衡
  - 熔断降级
  - 限流保护
  - 异步处理

- **资源利用**：
  - 连接池管理
  - 资源复用
  - 批处理优化
  - 适当缓存

### 网络性能优化策略
- **客户端优化**：
  - 连接复用
  - DNS缓存
  - 请求合并
  - 压缩传输
  - 异步请求

- **服务端优化**：
  - IO多路复用
  - 内存优化（对象池等）
  - CPU优化（避免锁竞争）
  - 数据库访问优化
  - 合理使用缓存

- **协议优化**：
  - HTTP/2多路复用
  - WebSocket减少握手
  - 二进制协议减少开销
  - 批量处理减少往返

- **监控分析**：
  - 性能指标监控
  - 分布式追踪
  - 瓶颈分析
  - 持续优化

## 实践练习

### 1. 实现一个简单的聊天服务器
开发一个支持多用户实时通信的TCP聊天服务器，要求：
- 支持用户注册和登录
- 实现群聊和私聊功能
- 支持上线/下线通知
- 实现简单的聊天记录存储
- 开发配套的命令行客户端

### 2. 开发HTTP代理服务器
实现一个HTTP代理服务器，功能包括：
- 支持HTTP/HTTPS代理
- 实现请求和响应的日志记录
- 添加请求过滤功能
- 支持基本的缓存机制
- 实现简单的负载均衡

### 3. 创建WebSocket实时通信系统
开发一个基于WebSocket的实时通信系统：
- 实现消息推送功能
- 支持不同主题的发布-订阅
- 处理连接断开和重连
- 实现消息持久化
- 添加用户在线状态管理

### 4. 编写网络性能测试工具
设计一个网络性能测试工具：
- 支持HTTP/TCP/UDP协议测试
- 实现并发请求模拟
- 收集响应时间、吞吐量等指标
- 生成性能报告和图表
- 支持测试脚本配置

### 5. 实现分布式网络爬虫
开发一个高性能的分布式网络爬虫：
- 支持URL队列管理
- 实现分布式工作节点
- 添加网页解析和数据提取
- 支持爬取速率控制
- 实现爬取结果存储和索引 