# 排序算法

排序算法是计算机科学中最基础也是最重要的算法之一。排序算法的目的是将一组数据按照特定顺序（通常是升序或降序）重新排列。

本目录包含以下常见排序算法的Java实现及详细讲解：

1. [冒泡排序 (Bubble Sort)](./BubbleSort.md)
2. [选择排序 (Selection Sort)](./SelectionSort.md)
3. [插入排序 (Insertion Sort)](./InsertionSort.md)
4. [希尔排序 (Shell Sort)](./ShellSort.md)
5. [归并排序 (Merge Sort)](./MergeSort.md)
6. [快速排序 (Quick Sort)](./QuickSort.md)
7. [堆排序 (Heap Sort)](./HeapSort.md)
8. [计数排序 (Counting Sort)](./CountingSort.md)
9. [桶排序 (Bucket Sort)](./BucketSort.md)
10. [基数排序 (Radix Sort)](./RadixSort.md)

## 排序算法比较

| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 | 最好时间复杂度 | 空间复杂度 | 稳定性 |
|---------|--------------|--------------|--------------|----------|-------|
| 冒泡排序 | O(n²)        | O(n²)        | O(n)         | O(1)     | 稳定   |
| 选择排序 | O(n²)        | O(n²)        | O(n²)        | O(1)     | 不稳定 |
| 插入排序 | O(n²)        | O(n²)        | O(n)         | O(1)     | 稳定   |
| 希尔排序 | O(nlog₂n)    | O(n²)        | O(n)         | O(1)     | 不稳定 |
| 归并排序 | O(nlogn)     | O(nlogn)     | O(nlogn)     | O(n)     | 稳定   |
| 快速排序 | O(nlogn)     | O(n²)        | O(nlogn)     | O(logn)  | 不稳定 |
| 堆排序   | O(nlogn)     | O(nlogn)     | O(nlogn)     | O(1)     | 不稳定 |
| 计数排序 | O(n+k)       | O(n+k)       | O(n+k)       | O(n+k)   | 稳定   |
| 桶排序   | O(n+k)       | O(n²)        | O(n)         | O(n+k)   | 稳定   |
| 基数排序 | O(n×k)       | O(n×k)       | O(n×k)       | O(n+k)   | 稳定   |

*注：n是数据规模，k是数据范围（计数排序中为最大值与最小值的差，桶排序中为桶的数量，基数排序中为位数）。*

## 排序算法的稳定性

排序算法的稳定性指的是相同大小的元素在排序前后是否保持相对位置不变。
- **稳定**：如果a原本在b前面，且a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b前面，且a=b，排序之后a可能会出现在b的后面。

## 如何选择排序算法？

选择排序算法时，需要考虑以下因素：
1. 数据规模：对于小规模数据，简单排序算法（如插入排序）可能更高效
2. 数据分布：针对特定分布的数据，某些算法可能表现更好
3. 稳定性要求：某些应用场景可能需要稳定的排序算法
4. 空间复杂度要求：内存受限情况下，应选择原地排序算法
5. 是否可以并行化：某些算法（如归并排序）更容易并行处理 