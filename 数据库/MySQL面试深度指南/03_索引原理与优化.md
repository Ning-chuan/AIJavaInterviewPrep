# 第3章：索引原理与优化

## 3.1 索引基础概念
### 索引的定义与作用
索引是数据库中对某一列或多列的值进行预排序的数据结构，其通过不断缩小想要获取数据的范围来筛选出最终想要的结果，是数据库中用来提高性能的最常用工具。

**作用**：
- 加快数据检索速度（大大减少磁盘I/O次数）
- 保证数据的唯一性（主键索引、唯一索引）
- 实现数据的高效排序
- 加速表与表之间的连接

### 索引的种类
1. **主键索引（PRIMARY KEY）**：
   - 唯一标识表中每一行数据
   - 不允许NULL值
   - 一个表只能有一个主键索引

2. **唯一索引（UNIQUE）**：
   - 确保索引列的值唯一
   - 允许NULL值（但只能有一个）
   - 一个表可以有多个唯一索引

3. **普通索引（INDEX）**：
   - 最基本的索引类型，没有唯一性限制
   - 允许NULL值

4. **联合索引（COMPOSITE INDEX）**：
   - 对多个列建立的索引
   - 遵循最左前缀原则

5. **全文索引（FULLTEXT）**：
   - 用于全文搜索
   - 只支持MyISAM和InnoDB引擎
   - 适用于CHAR、VARCHAR和TEXT类型

6. **空间索引（SPATIAL）**：
   - 用于地理空间数据类型
   - 只支持MyISAM和InnoDB引擎

### 索引的数据结构
1. **B+树索引**：
   - MySQL默认使用的索引结构
   - InnoDB和MyISAM都支持
   - 所有数据都存储在叶子节点
   - 叶子节点之间通过指针连接，方便范围查询

2. **Hash索引**：
   - 基于哈希表实现
   - 只支持等值查询，不支持排序和范围查询
   - 内存型数据库常用
   - 在Memory存储引擎中支持

3. **R树索引**：
   - 用于空间数据索引
   - 支持多维数据类型

4. **全文索引**：
   - 特殊的数据结构，用于解决全文搜索问题

### 聚簇索引与非聚簇索引
**聚簇索引（Clustered Index）**：
- 数据行与索引存储在一起
- 表中数据按照主键顺序物理存储
- 一个表只能有一个聚簇索引
- InnoDB默认使用主键作为聚簇索引
- 若无主键，选择第一个不含NULL的唯一索引
- 若都没有，InnoDB会生成隐藏的行ID作为聚簇索引

**非聚簇索引（Secondary Index/非聚簇索引）**：
- 索引结构和数据分开存储
- 索引叶子节点存储的是主键值
- 查询时可能需要回表操作
- MyISAM中所有索引都是非聚簇索引

## 3.2 B+树索引深度剖析
### B+树结构特点
1. **多路平衡查找树**：每个节点可以拥有多个子节点
2. **所有叶子节点在同一层**：保证查询稳定性
3. **非叶子节点只存储键值信息**：不存储数据，可以存储更多索引键
4. **所有数据都存储在叶子节点**：数据访问更高效
5. **叶子节点之间用指针连接**：便于范围查询
6. **树高较低**：通常2-4层可存储百万到千万级数据

**B+树节点结构**：
- 内部节点：[key1, key2, ..., keyN] + [pointer1, pointer2, ..., pointerN+1]
- 叶子节点：[key1:data1, key2:data2, ..., keyN:dataN] + [next_leaf_pointer]

### 为什么MySQL选择B+树作为索引结构
1. **磁盘访问特性**：B+树节点大小设计为一个或多个磁盘页大小，减少I/O次数
2. **范围查询高效**：叶子节点链表结构支持高效的范围扫描
3. **高扇出性**：单个节点可以包含更多索引条目，降低树的高度
4. **更好的缓存特性**：非叶子节点只存储索引信息，体积小，可以缓存更多索引
5. **查询稳定性**：所有查询都要访问叶子节点，路径长度一致

### B+树与其他数据结构的对比
1. **B+树 vs B树**：
   - B+树所有数据都在叶子节点，B树的非叶节点也存储数据
   - B+树叶子节点之间有链表连接，利于范围查询
   - B+树非叶子节点不保存数据，相同磁盘空间可以容纳更多索引项

2. **B+树 vs 红黑树**：
   - 红黑树是二叉树，高度较高，I/O次数多
   - B+树是多路平衡树，高度低，适合磁盘存储
   - 红黑树适合内存型数据结构，不适合大量索引存储

3. **B+树 vs Hash表**：
   - Hash查询时间复杂度O(1)，但不支持范围和排序查询
   - B+树支持范围查询和排序
   - B+树更适合数据库场景的多样化查询需求

### 索引的物理存储结构
在InnoDB中：
- 表空间由段（segment）、区（extent）、页（page）、行（row）组成
- 索引以B+树形式存储在表空间中
- 标准页大小16KB（可配置）
- 主键索引（聚簇索引）的叶子节点存储整行数据
- 二级索引（非聚簇索引）叶子节点存储主键值

## 3.3 索引优化策略
### 覆盖索引
指查询时所需的数据全部在索引中就能找到，无需回表查询。

**优势**：
- 避免回表操作，减少磁盘I/O
- 减少随机I/O，变随机访问为顺序访问
- 显著提高查询性能

**实现方式**：
```sql
-- 建立(name, age)联合索引
CREATE INDEX idx_name_age ON user(name, age);

-- 使用覆盖索引的查询（无需回表）
SELECT name, age FROM user WHERE name = '张三';
```

### 最左前缀原则
联合索引的使用原则，必须按照索引定义的顺序使用，从最左列开始，不能跳过中间列。

**示例**：
对于联合索引(A, B, C)：
- WHERE A=? 可以使用索引
- WHERE A=? AND B=? 可以使用索引
- WHERE A=? AND B=? AND C=? 可以使用索引
- WHERE B=? AND C=? 不能使用该索引
- WHERE A=? AND C=? 只能使用A列索引

**索引列顺序选择**：
- 优先选择区分度高的列
- 考虑查询条件常用顺序
- 将等值查询的列放在前面，范围查询的列放后面

### 索引下推
MySQL 5.6引入的优化，可以在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。

**案例**：
```sql
-- 有联合索引(name, age)
SELECT * FROM user WHERE name LIKE '张%' AND age = 25;
```
- 不使用索引下推：先找出所有name以"张"开头的记录，回表取出完整记录，再筛选age=25的记录
- 使用索引下推：在索引中先判断name以"张"开头且age=25的记录，再回表获取这些记录

### 索引合并
指MySQL使用多个单列索引合并产生结果，常见的索引合并策略：

1. **交集合并（Intersect）**：
```sql
-- 分别使用name和age上的索引，取交集
SELECT * FROM user WHERE name = '张三' AND age = 25;
```

2. **并集合并（Union）**：
```sql
-- 分别使用name和age上的索引，取并集
SELECT * FROM user WHERE name = '张三' OR age = 25;
```

3. **排序合并（Sort-Union）**：
```sql
-- 在某些情况下MySQL会对结果进行排序再合并
SELECT * FROM user WHERE name = '张三' OR age = 25 ORDER BY id;
```

### 前缀索引
对字符串列的前几个字符建立索引，适用于长字符串字段。

**优势**：
- 减小索引空间占用
- 提高索引效率

**设计要点**：
- 选择合适的前缀长度（兼顾区分度和空间占用）
- 通过统计不同前缀长度的选择性来确定

```sql
-- 统计字段在不同前缀长度下的区分度
SELECT COUNT(DISTINCT LEFT(email, 5))/COUNT(*) FROM users;
SELECT COUNT(DISTINCT LEFT(email, 10))/COUNT(*) FROM users;

-- 创建前缀索引
CREATE INDEX idx_email ON users(email(10));
```

### 避免索引失效的情况
1. **使用函数或表达式**：
```sql
-- 错误用法（索引失效）
SELECT * FROM users WHERE YEAR(create_time) = 2023;
-- 正确用法
SELECT * FROM users WHERE create_time >= '2023-01-01' AND create_time < '2024-01-01';
```

2. **隐式类型转换**：
```sql
-- 如果phone是varchar类型，此查询会导致索引失效
SELECT * FROM users WHERE phone = 12345678;
```

3. **使用!=或<>操作符**：可能导致索引失效

4. **使用OR连接不同列**：如果没有覆盖所有条件的索引，可能导致全表扫描

5. **使用LIKE '%xxx'**：前缀通配符会导致索引失效

6. **对索引列使用IS NULL或IS NOT NULL**：某些情况下可能使用不到索引

7. **在WHERE子句中对索引列进行运算**：
```sql
-- 错误用法（索引失效）
SELECT * FROM products WHERE price + 10 > 100;
-- 正确用法
SELECT * FROM products WHERE price > 90;
```

## 3.4 索引设计原则
### 如何选择合适的索引列
1. **高频查询条件列**：经常出现在WHERE、JOIN、ORDER BY和GROUP BY子句中的列

2. **高选择性列**：不同值越多，选择性越高
   - 计算方式：`COUNT(DISTINCT column_name) / COUNT(*)`
   - 理想情况下接近1，表示几乎每个值都不同

3. **数据量较大的表**：小表可能全表扫描更快

4. **更新频率低的列**：索引会增加写操作的开销

5. **较窄的列**：索引占用空间越小越好

### 索引列的顺序决策
1. **区分度优先**：将选择性更高的列放在前面

2. **常用查询优先**：将常用于等值查询的列放在前面

3. **范围查询放最后**：范围查询会导致其后列的索引失效

4. **顺序一致性**：查询条件的顺序应与索引列顺序一致

**示例**：
```sql
-- 假设三个条件的查询频率和选择性：
-- user_id：高频、高选择性
-- status：高频、低选择性
-- create_time：中频、范围查询

-- 推荐索引设计
CREATE INDEX idx_user_status_time ON orders(user_id, status, create_time);
```

### 避免索引过多
索引过多的问题：
- 增加存储空间占用
- 降低写入性能（INSERT/UPDATE/DELETE）
- 增加优化器选择索引的复杂度

控制策略：
1. **合并相似索引**：将多个单列索引合并为联合索引
2. **定期检查索引使用情况**：删除从未使用的索引
3. **控制每个表的索引数量**：通常不超过5-6个
4. **平衡读写性能**：根据业务特点调整索引策略

### A合理使用联合索引
使用原则：
1. **遵循最左前缀原则**
2. **考虑查询模式**：分析常见查询组合
3. **减少单列索引**：尽量用联合索引替代多个单列索引
4. **覆盖索引设计**：设计能够覆盖常用查询的索引

优化示例：
```sql
-- 优化前：三个单列索引
CREATE INDEX idx_name ON students(name);
CREATE INDEX idx_class ON students(class_id);
CREATE INDEX idx_score ON students(score);

-- 优化后：根据查询模式创建联合索引
CREATE INDEX idx_class_name ON students(class_id, name);
CREATE INDEX idx_class_score ON students(class_id, score);
```

## 3.5 常见面试题
### 1. InnoDB的主键索引和非主键索引有什么区别？
**主键索引（聚簇索引）**：
- 数据存储在索引的叶子节点上
- 一个表只能有一个聚簇索引
- 默认使用主键作为聚簇索引
- 物理上按主键顺序存储

**非主键索引（二级索引）**：
- 索引的叶子节点存储的是主键值，而不是行数据
- 查询时可能需要回表（通过主键再去聚簇索引查询）
- 可以有多个

### 2. 什么是回表查询？如何优化？
**回表查询**：通过二级索引找到主键值，再通过主键值到聚簇索引中查找记录的过程。

**优化方法**：
1. **使用覆盖索引**：所有需要的字段都在索引中
2. **建立联合索引**：将常查询的列加入到索引中
3. **使用索引下推**：在索引遍历过程中进行过滤
4. **主键设计**：使用自增主键减少页分裂和碎片

### 3. 索引是如何提升查询效率的？
1. **减少数据访问量**：索引可以快速定位到需要查询的数据，避免全表扫描
2. **避免排序操作**：利用索引的有序性，减少排序开销
3. **加速表连接**：使用被索引的列进行表连接可以大大提高效率
4. **提高数据检索速度**：B+树高效的查找算法和磁盘I/O特性
5. **利用覆盖索引**：直接从索引获取数据，避免回表操作

**对比说明**：
- 无索引时，查找一条记录需要遍历整个表
- 有索引时，通过B+树的高效查找（通常2-4次I/O）即可定位数据

### 4. 什么情况下索引会失效？
1. **使用函数或表达式**：`WHERE MONTH(create_time) = 5`
2. **类型转换**：隐式或显式的类型转换
3. **使用不等于操作符**：`!=` 或 `<>`
4. **使用OR连接不同列**：如果没有适合的索引
5. **LIKE以通配符开头**：`LIKE '%abc'`
6. **字符串不加引号**：导致隐式类型转换
7. **对索引列进行运算**：`WHERE age + 1 = 18`
8. **使用IS NULL/IS NOT NULL**：取决于数据分布和优化器
9. **违反最左前缀原则**：跳过联合索引前面的列
10. **数据分布不均**：若优化器认为全表扫描更快，则不使用索引

### 5. 如何分析和优化慢查询？
**分析方法**：
1. **开启慢查询日志**：
```sql
SET GLOBAL slow_query_log = 1;
SET GLOBAL long_query_time = 1; -- 设置慢查询阈值（秒）
```

2. **使用EXPLAIN分析执行计划**：
```sql
EXPLAIN SELECT * FROM users WHERE name = '张三';
```
关注以下关键指标：
- `type`：system > const > eq_ref > ref > range > index > ALL
- `key`：实际使用的索引
- `rows`：估计需要扫描的行数
- `Extra`：额外信息（如"Using index"表示使用了覆盖索引）

3. **使用SHOW PROFILE分析资源消耗**：
```sql
SET profiling = 1;
-- 执行查询
SHOW PROFILES;
SHOW PROFILE FOR QUERY [query_id];
```

**优化策略**：
1. **索引优化**：
   - 添加合适的索引
   - 调整索引列顺序
   - 使用覆盖索引

2. **SQL改写**：
   - 避免SELECT *，只查询需要的字段
   - 拆分复杂查询为简单查询
   - 使用LIMIT限制结果集大小

3. **表结构优化**：
   - 选择合适的字段类型
   - 表分区或分表
   - 历史数据归档

4. **服务器参数调优**：
   - 调整缓冲池大小
   - 优化排序缓冲区
   - 调整并发连接数

5. **硬件升级**：
   - 增加内存
   - 使用SSD存储
   - 增加CPU核心数

## 本章要点
- 深刻理解索引底层数据结构（B+树）是优化查询性能的关键
- 正确选择索引类型和索引列对于数据库性能至关重要
- 遵循最左前缀原则和覆盖索引设计能有效减少回表操作
- 关注索引失效的各种情况，避免不必要的全表扫描
- 定期分析和优化慢查询，保持数据库高效运行
- 在索引设计时需平衡查询性能和写入性能
- 理解InnoDB存储引擎的聚簇索引和二级索引的实现原理 